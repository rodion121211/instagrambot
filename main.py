import discord
from discord.ext import commands, tasks
import os
import random
from dotenv import load_dotenv
import json
import asyncio
from pymongo import MongoClient
from pymongo.errors import ConnectionFailure
import datetime
import ssl

# Carrega vari√°veis do arquivo .env
load_dotenv()

# Configura√ß√£o do MongoDB
MONGODB_CONNECTION_STRING = os.getenv('MONGODB_TOKEN')

# String alternativa sem SRV (caso SRV falhe) - ser√° gerada dinamicamente se necess√°rio
MONGODB_CONNECTION_STRING_ALT = None

# Cliente MongoDB
mongo_client = None
db = None

def init_mongodb():
    """Inicializa a conex√£o com MongoDB com timeout r√°pido"""
    global mongo_client, db
    
    if not MONGODB_CONNECTION_STRING:
        print("‚ùå MONGODB_TOKEN n√£o encontrado nas vari√°veis de ambiente!")
        print("üîß Configure MONGODB_TOKEN nos Secrets do Replit com sua connection string do MongoDB Atlas")
        return False
    
    # Configura√ß√µes otimizadas e simplificadas
    connection_configs = [
        {
            "uri": MONGODB_CONNECTION_STRING,
            "options": {
                "serverSelectionTimeoutMS": 5000,
                "connectTimeoutMS": 3000,
                "socketTimeoutMS": 5000,
                "maxPoolSize": 1,
                "retryWrites": True,
                "w": 'majority'
            },
            "name": "MongoDB Atlas SRV (Simplificado)"
        },
        {
            "uri": MONGODB_CONNECTION_STRING.replace("mongodb+srv://", "mongodb://").replace("cluster0.9dbl7a5.mongodb.net", "cluster0-shard-00-00.9dbl7a5.mongodb.net:27017,cluster0-shard-00-01.9dbl7a5.mongodb.net:27017,cluster0-shard-00-02.9dbl7a5.mongodb.net:27017").replace("/?", "/instagram_mxp?ssl=true&replicaSet=atlas-rs0-shard-0&authSource=admin&"),
            "options": {
                "serverSelectionTimeoutMS": 3000,
                "connectTimeoutMS": 2000,
                "socketTimeoutMS": 3000,
                "maxPoolSize": 1,
                "retryWrites": False
            },
            "name": "MongoDB Atlas Direto (Sem SRV)"
        }
    ]
    
    for config in connection_configs:
        try:
            print(f"üîÑ Tentando: {config['name']}")
            mongo_client = MongoClient(config["uri"], **config["options"])
            
            # Testa a conex√£o com timeout r√°pido
            mongo_client.admin.command('ping')
            
            # Pega o nome do banco
            if "mongodb+srv://" in config["uri"] or "mongodb://" in config["uri"]:
                if "/" in config["uri"].split("@")[1] and "?" in config["uri"]:
                    db_name = config["uri"].split("/")[-1].split("?")[0]
                    if db_name and db_name != "":
                        db = mongo_client[db_name]
                    else:
                        db = mongo_client.instagram_mxp
                else:
                    db = mongo_client.instagram_mxp
            else:
                db = mongo_client.instagram_mxp
            
            print(f"‚úÖ MongoDB conectado: {config['name']}")
            print(f"üìä Banco: {db.name}")
            return True
            
        except Exception as e:
            print(f"‚ùå Falha em {config['name']}: {str(e)[:50]}...")
            if mongo_client:
                try:
                    mongo_client.close()
                except:
                    pass
            continue
    
    print("‚ùå MongoDB indispon√≠vel - bot funcionar√° apenas localmente")
    print("üí° Para resolver:")
    print("   1. Verifique MONGODB_TOKEN nos Secrets")
    print("   2. Use connection string sem SRV se poss√≠vel")
    print("   3. Whitelist IP 0.0.0.0/0 no MongoDB Atlas")
    return False

class ProfileUpdateModal(discord.ui.Modal, title='Atualizar Perfil'):
    def __init__(self, current_username="", current_profession=""):
        super().__init__()
        
        self.username = discord.ui.TextInput(
            label='Nome de usu√°rio',
            placeholder='Digite seu nome de usu√°rio...',
            required=True,
            max_length=20,
            default=current_username
        )
        
        self.profession = discord.ui.TextInput(
            label='Profiss√£o',
            placeholder='Digite sua profiss√£o...',
            required=True,
            max_length=50,
            default=current_profession
        )
        
        self.add_item(self.username)
        self.add_item(self.profession)

    async def on_submit(self, interaction: discord.Interaction):
        user_id = str(interaction.user.id)

        # Inicializa dados do usu√°rio se n√£o existir
        if user_id not in user_data:
            user_data[user_id] = {
                'username': None,
                'total_likes': 0,
                'posts_count': 0,
                'followers': 0,
                'profession': None,
                'thumbnail_url': None,
                'embed_image_url': None,
                'profile_color': 0x9932CC
            }

        # Atualiza os dados
        user_data[user_id]['username'] = str(self.username.value)
        user_data[user_id]['profession'] = str(self.profession.value)
        
        # Salva imediatamente
        save_user_data()
        print(f"üíæ Dados salvos ap√≥s atualiza√ß√£o de perfil: {user_id}")

        # Embed de confirma√ß√£o
        embed = discord.Embed(
            title="‚úÖ Perfil Atualizado!",
            description="Suas informa√ß√µes foram atualizadas com sucesso!",
            color=0x00FF00
        )
        embed.add_field(
            name="üë§ Nome de usu√°rio",
            value=f"@{self.username.value}",
            inline=True
        )
        embed.add_field(
            name="üíº Profiss√£o",
            value=f"{self.profession.value}",
            inline=True
        )
        embed.set_thumbnail(url=interaction.user.display_avatar.url)
        embed.set_footer(text=f"Atualizado por {interaction.user.display_name}")

        # Responde com confirma√ß√£o
        await interaction.response.send_message(embed=embed, ephemeral=True)

class BioUpdateModal(discord.ui.Modal, title='Atualizar Bio e Status'):
    def __init__(self, current_bio="", current_status=""):
        super().__init__()
        
        self.bio = discord.ui.TextInput(
            label='Bio/Descri√ß√£o',
            placeholder='Conte um pouco sobre voc√™...',
            required=False,
            max_length=200,
            style=discord.TextStyle.paragraph,
            default=current_bio
        )
        
        self.status = discord.ui.TextInput(
            label='Status Personalizado',
            placeholder='Ex: Trabalhando duro üí™',
            required=False,
            max_length=50,
            default=current_status
        )
        
        self.add_item(self.bio)
        self.add_item(self.status)

    async def on_submit(self, interaction: discord.Interaction):
        user_id = str(interaction.user.id)

        # Inicializa dados do usu√°rio se n√£o existir
        if user_id not in user_data:
            user_data[user_id] = {
                'username': None,
                'total_likes': 0,
                'posts_count': 0,
                'followers': 0,
                'profession': None,
                'thumbnail_url': None,
                'embed_image_url': None,
                'profile_color': 0x9932CC,
                'bio': None,
                'status': None
            }

        # Atualiza os dados
        user_data[user_id]['bio'] = str(self.bio.value) if self.bio.value else None
        user_data[user_id]['status'] = str(self.status.value) if self.status.value else None
        
        # Salva imediatamente
        save_user_data()
        print(f"üíæ Bio e status salvos para: {user_id}")

        # Embed de confirma√ß√£o
        embed = discord.Embed(
            title="‚úÖ Bio e Status Atualizados!",
            description="Suas informa√ß√µes foram atualizadas com sucesso!",
            color=user_data[user_id].get('profile_color', 0x9932CC)
        )
        
        if self.bio.value:
            embed.add_field(
                name="üìù Nova Bio",
                value=f"{self.bio.value}",
                inline=False
            )
        
        if self.status.value:
            embed.add_field(
                name="üí´ Novo Status",
                value=f"{self.status.value}",
                inline=False
            )
        
        embed.set_thumbnail(url=interaction.user.display_avatar.url)
        embed.set_footer(text=f"Atualizado por {interaction.user.display_name}")

        # Responde com confirma√ß√£o
        await interaction.response.send_message(embed=embed, ephemeral=True)

class LinksUpdateModal(discord.ui.Modal, title='Atualizar Links Sociais'):
    def __init__(self, current_instagram="", current_youtube="", current_tiktok=""):
        super().__init__()
        
        self.instagram = discord.ui.TextInput(
            label='Instagram (@username)',
            placeholder='@seu_instagram',
            required=False,
            max_length=30,
            default=current_instagram
        )
        
        self.youtube = discord.ui.TextInput(
            label='YouTube (Canal)',
            placeholder='Nome do seu canal',
            required=False,
            max_length=50,
            default=current_youtube
        )
        
        self.tiktok = discord.ui.TextInput(
            label='TikTok (@username)',
            placeholder='@seu_tiktok',
            required=False,
            max_length=30,
            default=current_tiktok
        )
        
        self.add_item(self.instagram)
        self.add_item(self.youtube)
        self.add_item(self.tiktok)

    async def on_submit(self, interaction: discord.Interaction):
        user_id = str(interaction.user.id)

        # Inicializa dados do usu√°rio se n√£o existir
        if user_id not in user_data:
            user_data[user_id] = {
                'username': None,
                'total_likes': 0,
                'posts_count': 0,
                'followers': 0,
                'profession': None,
                'thumbnail_url': None,
                'embed_image_url': None,
                'profile_color': 0x9932CC,
                'social_links': {}
            }

        # Inicializa links sociais se n√£o existir
        if 'social_links' not in user_data[user_id]:
            user_data[user_id]['social_links'] = {}

        # Atualiza os links
        user_data[user_id]['social_links']['instagram'] = str(self.instagram.value) if self.instagram.value else None
        user_data[user_id]['social_links']['youtube'] = str(self.youtube.value) if self.youtube.value else None
        user_data[user_id]['social_links']['tiktok'] = str(self.tiktok.value) if self.tiktok.value else None
        
        # Salva imediatamente
        save_user_data()
        print(f"üíæ Links sociais salvos para: {user_id}")

        # Embed de confirma√ß√£o
        embed = discord.Embed(
            title="‚úÖ Links Sociais Atualizados!",
            description="Seus links foram atualizados com sucesso!",
            color=user_data[user_id].get('profile_color', 0x9932CC)
        )
        
        links_text = ""
        if self.instagram.value:
            links_text += f"üì∑ Twitter: {self.instagram.value}\n"
        if self.youtube.value:
            links_text += f"üé• YouTube: {self.youtube.value}\n"
        if self.tiktok.value:
            links_text += f"üéµ TikTok: {self.tiktok.value}\n"
        
        if links_text:
            embed.add_field(
                name="üîó Seus Links",
                value=links_text,
                inline=False
            )
        else:
            embed.add_field(
                name="üîó Links Removidos",
                value="Todos os links sociais foram removidos do seu perfil.",
                inline=False
            )
        
        embed.set_thumbnail(url=interaction.user.display_avatar.url)
        embed.set_footer(text=f"Atualizado por {interaction.user.display_name}")

        # Responde com confirma√ß√£o
        await interaction.response.send_message(embed=embed, ephemeral=True)

class ImageTypeView(discord.ui.View):
    def __init__(self, user_id):
        super().__init__(timeout=300)
        self.user_id = user_id

    @discord.ui.button(label='üì∏ Thumbnail (Imagem Pequena)', style=discord.ButtonStyle.primary)
    async def thumbnail_button(self, interaction: discord.Interaction, button: discord.ui.Button):
        embed = discord.Embed(
            title="üì∏ Enviar Thumbnail",
            description="Envie a imagem que ser√° usada como **thumbnail** (imagem pequena) do seu perfil.",
            color=0x00FF00
        )
        embed.add_field(
            name="üìù Instru√ß√µes:",
            value="‚Ä¢ Envie apenas **1 imagem**\n‚Ä¢ A imagem ser√° automaticamente salva\n‚Ä¢ Voc√™ tem **60 segundos** para enviar",
            inline=False
        )

        await interaction.response.send_message(embed=embed, ephemeral=True)

        # Aguarda a imagem
        def check(m):
            return m.author.id == interaction.user.id and len(m.attachments) > 0

        try:
            message = await bot.wait_for('message', check=check, timeout=60.0)

            if message.attachments:
                image_url = message.attachments[0].url

                # Inicializa dados do usu√°rio se n√£o existir
                if self.user_id not in user_data:
                    user_data[self.user_id] = {
                        'username': None,
                        'total_likes': 0,
                        'posts_count': 0,
                        'followers': 0,
                        'profession': None,
                        'thumbnail_url': None,
                        'embed_image_url': None
                    }

                # Salva a URL da thumbnail
                user_data[self.user_id]['thumbnail_url'] = image_url
                save_user_data()

                success_embed = discord.Embed(
                    title="‚úÖ Thumbnail Atualizada!",
                    description="Sua thumbnail foi salva com sucesso!",
                    color=0x00FF00
                )
                success_embed.set_thumbnail(url=image_url)

                await message.reply(embed=success_embed)

        except asyncio.TimeoutError:
            timeout_embed = discord.Embed(
                title="‚è∞ Tempo Esgotado",
                description="Voc√™ demorou muito para enviar a imagem. Tente novamente.",
                color=0xFF0000
            )
            channel = bot.get_channel(interaction.channel_id) or interaction.user
            await channel.send(embed=timeout_embed)

    @discord.ui.button(label='üñºÔ∏è Imagem do Embed (Imagem Grande)', style=discord.ButtonStyle.secondary)
    async def embed_image_button(self, interaction: discord.Interaction, button: discord.ui.Button):
        embed = discord.Embed(
            title="üñºÔ∏è Enviar Imagem do Embed",
            description="Envie a imagem que ser√° usada como **imagem do embed** (imagem grande) do seu perfil.",
            color=0x0099FF
        )
        embed.add_field(
            name="üìù Instru√ß√µes:",
            value="‚Ä¢ Envie apenas **1 imagem**\n‚Ä¢ A imagem ser√° automaticamente salva\n‚Ä¢ Voc√™ tem **60 segundos** para enviar",
            inline=False
        )

        await interaction.response.send_message(embed=embed, ephemeral=True)

        # Aguarda a imagem
        def check(m):
            return m.author.id == interaction.user.id and len(m.attachments) > 0

        try:
            message = await bot.wait_for('message', check=check, timeout=60.0)

            if message.attachments:
                image_url = message.attachments[0].url

                # Inicializa dados do usu√°rio se n√£o existir
                if self.user_id not in user_data:
                    user_data[self.user_id] = {
                        'username': None,
                        'total_likes': 0,
                        'posts_count': 0,
                        'followers': 0,
                        'profession': None,
                        'thumbnail_url': None,
                        'embed_image_url': None
                    }

                # Salva a URL da imagem do embed
                user_data[self.user_id]['embed_image_url'] = image_url
                save_user_data()

                success_embed = discord.Embed(
                    title="‚úÖ Imagem do Embed Atualizada!",
                    description="Sua imagem do embed foi salva com sucesso!",
                    color=0x00FF00
                )
                success_embed.set_image(url=image_url)

                await message.reply(embed=success_embed)

        except asyncio.TimeoutError:
            timeout_embed = discord.Embed(
                title="‚è∞ Tempo Esgotado",
                description="Voc√™ demorou muito para enviar a imagem. Tente novamente.",
                color=0xFF0000
            )
            channel = bot.get_channel(interaction.channel_id) or interaction.user
            await channel.send(embed=timeout_embed)

class ThemeSelectView(discord.ui.View):
    def __init__(self, user_id):
        super().__init__(timeout=300)
        self.user_id = user_id
        
        # Adiciona select menu com temas
        self.add_item(ThemeSelect(user_id))

    @discord.ui.button(label='üîô Voltar', style=discord.ButtonStyle.secondary, row=1)
    async def voltar_button(self, interaction: discord.Interaction, button: discord.ui.Button):
        if str(interaction.user.id) != self.user_id:
            await interaction.response.send_message("‚ùå Este menu n√£o √© seu!", ephemeral=True)
            return
        
        # Volta ao menu principal de atualiza√ß√£o
        await show_main_update_menu(interaction, self.user_id)

class BadgeSelectView(discord.ui.View):
    def __init__(self, user_id):
        super().__init__(timeout=300)
        self.user_id = user_id
        
        # Adiciona select menu com badges
        self.add_item(BadgeSelect(user_id))

    @discord.ui.button(label='üîô Voltar', style=discord.ButtonStyle.secondary, row=1)
    async def voltar_button(self, interaction: discord.Interaction, button: discord.ui.Button):
        if str(interaction.user.id) != self.user_id:
            await interaction.response.send_message("‚ùå Este menu n√£o √© seu!", ephemeral=True)
            return
        
        # Volta ao menu principal de atualiza√ß√£o
        await show_main_update_menu(interaction, self.user_id)

class ColorSelectView(discord.ui.View):
    def __init__(self, user_id):
        super().__init__(timeout=300)
        self.user_id = user_id
        
        # Adiciona select menu com cores
        self.add_item(ColorSelect(user_id))

    @discord.ui.button(label='üîô Voltar', style=discord.ButtonStyle.secondary, row=1)
    async def voltar_button(self, interaction: discord.Interaction, button: discord.ui.Button):
        if str(interaction.user.id) != self.user_id:
            await interaction.response.send_message("‚ùå Este menu n√£o √© seu!", ephemeral=True)
            return
        
        # Volta ao menu principal de atualiza√ß√£o
        await show_main_update_menu(interaction, self.user_id)

class ThemeSelect(discord.ui.Select):
    def __init__(self, user_id):
        self.user_id = user_id
        
        # Temas dispon√≠veis
        themes = [
            ("üåü Cl√°ssico", "classico", "Tema padr√£o e elegante"),
            ("üî• Gamer", "gamer", "Para os apaixonados por games"),
            ("üíº Profissional", "profissional", "S√©rio e corporativo"),
            ("üé® Artista", "artista", "Criativo e colorido"),
            ("üå∏ Kawaii", "kawaii", "Fofo e ador√°vel"),
            ("üñ§ Dark Mode", "dark", "Escuro e minimalista"),
            ("üåà Pride", "pride", "Colorido e inclusivo"),
            ("‚ö° Neon", "neon", "Vibrante e futur√≠stico"),
            ("üåø Natural", "natural", "Verde e org√¢nico"),
            ("üëë Luxo", "luxo", "Dourado e premium")
        ]
        
        options = []
        for name, value, description in themes:
            options.append(discord.SelectOption(
                label=name,
                description=description,
                value=value
            ))
        
        super().__init__(
            placeholder="üé≠ Escolha um tema para seu perfil...",
            min_values=1,
            max_values=1,
            options=options
        )

    async def callback(self, interaction: discord.Interaction):
        if str(interaction.user.id) != self.user_id:
            await interaction.response.send_message("‚ùå Este menu n√£o √© seu!", ephemeral=True)
            return
        
        selected_theme = self.values[0]
        
        # Atualiza o tema do perfil
        user_data[self.user_id]['profile_theme'] = selected_theme
        save_user_data()
        
        # Mapeia nomes dos temas
        theme_names = {
            "classico": "üåü Cl√°ssico",
            "gamer": "üî• Gamer",
            "profissional": "üíº Profissional",
            "artista": "üé® Artista",
            "kawaii": "üå∏ Kawaii",
            "dark": "üñ§ Dark Mode",
            "pride": "üåà Pride",
            "neon": "‚ö° Neon",
            "natural": "üåø Natural",
            "luxo": "üëë Luxo"
        }
        
        theme_name = theme_names.get(selected_theme, "Tema Personalizado")
        
        # Embed de confirma√ß√£o
        embed = discord.Embed(
            title="üé≠ Tema Atualizado!",
            description=f"Seu tema do perfil foi alterado para **{theme_name}**!",
            color=user_data[self.user_id].get('profile_color', 0x9932CC)
        )
        embed.add_field(
            name="‚ú® Novo Tema",
            value=f"üéØ **{theme_name}**\nüìù Este tema influencia a apar√™ncia do seu perfil",
            inline=False
        )
        embed.set_thumbnail(url=interaction.user.display_avatar.url)
        embed.set_footer(text=f"Tema alterado por {interaction.user.display_name}")
        
        await interaction.response.edit_message(embed=embed, view=None)

class BadgeSelect(discord.ui.Select):
    def __init__(self, user_id):
        self.user_id = user_id
        
        # Badges dispon√≠veis
        badges = [
            ("üéÆ Gamer", "gamer", "Para os viciados em jogos"),
            ("üé® Artista", "artista", "Para os criativos"),
            ("üìö Estudante", "estudante", "Para quem ama estudar"),
            ("üíº Trabalhador", "trabalhador", "Para os profissionais"),
            ("üåü Streamer", "streamer", "Para os criadores de conte√∫do"),
            ("üéµ M√∫sico", "musico", "Para os amantes da m√∫sica"),
            ("üì∑ Fot√≥grafo", "fotografo", "Para quem ama fotografar"),
            ("‚öΩ Esportista", "esportista", "Para os atletas"),
            ("üçï Foodie", "foodie", "Para os amantes da comida"),
            ("üåç Viajante", "viajante", "Para os exploradores"),
            ("‚ùå Remover Badge", "remove", "Remove o badge atual")
        ]
        
        options = []
        for name, value, description in badges:
            options.append(discord.SelectOption(
                label=name,
                description=description,
                value=value
            ))
        
        super().__init__(
            placeholder="üèÜ Escolha um badge para seu perfil...",
            min_values=1,
            max_values=1,
            options=options
        )

    async def callback(self, interaction: discord.Interaction):
        if str(interaction.user.id) != self.user_id:
            await interaction.response.send_message("‚ùå Este menu n√£o √© seu!", ephemeral=True)
            return
        
        selected_badge = self.values[0]
        
        # Atualiza o badge do perfil
        if selected_badge == "remove":
            user_data[self.user_id]['profile_badge'] = None
        else:
            user_data[self.user_id]['profile_badge'] = selected_badge
        
        save_user_data()
        
        # Mapeia nomes dos badges
        badge_names = {
            "gamer": "üéÆ Gamer",
            "artista": "üé® Artista",
            "estudante": "üìö Estudante",
            "trabalhador": "üíº Trabalhador",
            "streamer": "üåü Streamer",
            "musico": "üéµ M√∫sico",
            "fotografo": "üì∑ Fot√≥grafo",
            "esportista": "‚öΩ Esportista",
            "foodie": "üçï Foodie",
            "viajante": "üåç Viajante"
        }
        
        # Embed de confirma√ß√£o
        embed = discord.Embed(
            title="üèÜ Badge Atualizado!",
            color=user_data[self.user_id].get('profile_color', 0x9932CC)
        )
        
        if selected_badge == "remove":
            embed.description = "Seu badge foi removido do perfil!"
            embed.add_field(
                name="‚ùå Badge Removido",
                value="Agora voc√™ n√£o possui nenhum badge especial",
                inline=False
            )
        else:
            badge_name = badge_names.get(selected_badge, "Badge Personalizado")
            embed.description = f"Seu badge foi alterado para **{badge_name}**!"
            embed.add_field(
                name="‚ú® Novo Badge",
                value=f"üéØ **{badge_name}**\nüìù Este badge aparece no seu perfil",
                inline=False
            )
        
        embed.set_thumbnail(url=interaction.user.display_avatar.url)
        embed.set_footer(text=f"Badge alterado por {interaction.user.display_name}")
        
        await interaction.response.edit_message(embed=embed, view=None)

class ColorSelect(discord.ui.Select):
    def __init__(self, user_id):
        self.user_id = user_id
        
        # Cores dispon√≠veis
        colors = [
            ("üîµ Azul Marinho", "azul_marinho", 0x1E3A8A),
            ("‚ö´ Cinza Escuro", "cinza_escuro", 0x374151),
            ("üü¢ Verde Escuro", "verde_escuro", 0x4B5563),
            ("üî∑ Azul Petr√≥leo", "azul_petroleo", 0x0F766E),
            ("üç∑ Vinho", "vinho", 0x7F1D1D),
            ("üå∏ Rosa Claro", "rosa_claro", 0xF9A8D4),
            ("üíú Lavanda", "lavanda", 0xC084FC),
            ("ü™∏ Coral", "coral", 0xFB7185),
            ("‚òÅÔ∏è Azul C√©u", "azul_ceu", 0x38BDF8),
            ("ü¶Ñ Lil√°s", "lilas", 0xE9D5FF)
        ]
        
        options = []
        for name, value, hex_color in colors:
            options.append(discord.SelectOption(
                label=name,
                description=f"Cor hexadecimal: #{hex_color:06X}",
                value=value
            ))
        
        super().__init__(
            placeholder="üé® Escolha uma cor para seu perfil...",
            min_values=1,
            max_values=1,
            options=options
        )

    async def callback(self, interaction: discord.Interaction):
        if str(interaction.user.id) != self.user_id:
            await interaction.response.send_message("‚ùå Este menu n√£o √© seu!", ephemeral=True)
            return
        
        # Mapeamento das cores
        color_map = {
            "azul_marinho": 0x1E3A8A,
            "cinza_escuro": 0x374151,
            "verde_escuro": 0x4B5563,
            "azul_petroleo": 0x0F766E,
            "vinho": 0x7F1D1D,
            "rosa_claro": 0xF9A8D4,
            "lavanda": 0xC084FC,
            "coral": 0xFB7185,
            "azul_ceu": 0x38BDF8,
            "lilas": 0xE9D5FF
        }
        
        selected_color = self.values[0]
        color_hex = color_map[selected_color]
        color_name = get_color_name(color_hex)
        
        # Atualiza a cor do perfil
        user_data[self.user_id]['profile_color'] = color_hex
        save_user_data()
        
        # Embed de confirma√ß√£o
        embed = discord.Embed(
            title="üé® Cor Atualizada!",
            description=f"Sua cor do perfil foi alterada para **{color_name}**!",
            color=color_hex
        )
        embed.add_field(
            name="‚ú® Nova Cor",
            value=f"üéØ **{color_name}**\nüìù C√≥digo: `#{color_hex:06X}`",
            inline=False
        )
        embed.add_field(
            name="üí° Onde aparece:",
            value="‚Ä¢ Embed do seu perfil (`m!perfil`)\n‚Ä¢ Embed de atualiza√ß√£o\n‚Ä¢ Outros embeds relacionados ao seu perfil",
            inline=False
        )
        embed.set_thumbnail(url=interaction.user.display_avatar.url)
        embed.set_footer(text=f"Cor alterada por {interaction.user.display_name}")
        
        await interaction.response.edit_message(embed=embed, view=None)

def get_color_name(color_hex):
    """Retorna o nome da cor baseado no valor hexadecimal"""
    color_names = {
        0x1E3A8A: "Azul Marinho",
        0x374151: "Cinza Escuro", 
        0x4B5563: "Verde Escuro",
        0x0F766E: "Azul Petr√≥leo",
        0x7F1D1D: "Vinho",
        0xF9A8D4: "Rosa Claro",
        0xC084FC: "Lavanda",
        0xFB7185: "Coral",
        0x38BDF8: "Azul C√©u",
        0xE9D5FF: "Lil√°s",
        0x9932CC: "Roxo (Padr√£o)"
    }
    return color_names.get(color_hex, "Cor Personalizada")

async def show_main_update_menu(interaction, user_id):
    """Mostra o menu principal de atualiza√ß√£o de perfil"""
    user_data_info = user_data[user_id]
    current_username = user_data_info.get('username', '')
    current_profession = user_data_info.get('profession', '')
    current_bio = user_data_info.get('bio', '')
    current_status = user_data_info.get('status', '')
    current_theme = user_data_info.get('profile_theme', 'classico')
    current_badge = user_data_info.get('profile_badge', None)
    
    embed = discord.Embed(
        title="‚öôÔ∏è Central de Personaliza√ß√£o",
        description="Personalize seu perfil do Instagram MXP com v√°rias op√ß√µes!",
        color=user_data_info.get('profile_color', 0x9932CC)
    )
    
    # Informa√ß√µes b√°sicas
    embed.add_field(
        name="üìã Informa√ß√µes B√°sicas",
        value=f"**Nome:** {current_username or 'N√£o definido'}\n**Profiss√£o:** {current_profession or 'N√£o definido'}",
        inline=False
    )
    
    # Bio e Status
    bio_text = current_bio[:50] + "..." if current_bio and len(current_bio) > 50 else current_bio or "N√£o definida"
    status_text = current_status or "N√£o definido"
    embed.add_field(
        name="üí≠ Bio e Status",
        value=f"**Bio:** {bio_text}\n**Status:** {status_text}",
        inline=False
    )
    
    # Tema e Badge
    theme_names = {
        "classico": "üåü Cl√°ssico", "gamer": "üî• Gamer", "profissional": "üíº Profissional",
        "artista": "üé® Artista", "kawaii": "üå∏ Kawaii", "dark": "üñ§ Dark Mode",
        "pride": "üåà Pride", "neon": "‚ö° Neon", "natural": "üåø Natural", "luxo": "üëë Luxo"
    }
    badge_names = {
        "gamer": "üéÆ Gamer", "artista": "üé® Artista", "estudante": "üìö Estudante",
        "trabalhador": "üíº Trabalhador", "streamer": "üåü Streamer", "musico": "üéµ M√∫sico",
        "fotografo": "üì∑ Fot√≥grafo", "esportista": "‚öΩ Esportista", "foodie": "üçï Foodie", "viajante": "üåç Viajante"
    }
    
    current_theme_name = theme_names.get(current_theme, "üåü Cl√°ssico")
    current_badge_name = badge_names.get(current_badge, "Nenhum") if current_badge else "Nenhum"
    
    embed.add_field(
        name="üé≠ Apar√™ncia",
        value=f"**Tema:** {current_theme_name}\n**Badge:** {current_badge_name}\n**Cor:** {get_color_name(user_data_info.get('profile_color', 0x9932CC))}",
        inline=False
    )
    
    # Links sociais
    social_links = user_data_info.get('social_links', {})
    links_text = ""
    if social_links.get('instagram'): links_text += f"üì∑ {social_links['instagram']}\n"
    if social_links.get('youtube'): links_text += f"üé• {social_links['youtube']}\n"
    if social_links.get('tiktok'): links_text += f"üéµ {social_links['tiktok']}\n"
    if not links_text: links_text = "Nenhum link definido"
    
    embed.add_field(
        name="üîó Links Sociais",
        value=links_text,
        inline=False
    )
    
    embed.set_thumbnail(url="https://cdn.discordapp.com/emojis/1387842927602172125.png")
    embed.set_footer(text="Use os bot√µes abaixo para personalizar seu perfil")
    
    view = UpdateProfileView(current_username, current_profession, user_id)
    await interaction.response.edit_message(embed=embed, view=view)

class UpdateProfileView(discord.ui.View):
    def __init__(self, current_username="", current_profession="", user_id=None):
        super().__init__(timeout=300)
        self.current_username = current_username
        self.current_profession = current_profession
        self.user_id = user_id

    @discord.ui.button(label='Nome/Profiss√£o', style=discord.ButtonStyle.primary, emoji='üìù')
    async def open_modal(self, interaction: discord.Interaction, button: discord.ui.Button):
        modal = ProfileUpdateModal(self.current_username, self.current_profession)
        await interaction.response.send_modal(modal)

    @discord.ui.button(label='Bio/Status', style=discord.ButtonStyle.secondary, emoji='üí≠')
    async def bio_status_modal(self, interaction: discord.Interaction, button: discord.ui.Button):
        current_bio = user_data[self.user_id].get('bio', '')
        current_status = user_data[self.user_id].get('status', '')
        modal = BioUpdateModal(current_bio, current_status)
        await interaction.response.send_modal(modal)

    @discord.ui.button(label='Links Sociais', style=discord.ButtonStyle.success, emoji='üîó')
    async def links_modal(self, interaction: discord.Interaction, button: discord.ui.Button):
        social_links = user_data[self.user_id].get('social_links', {})
        current_instagram = social_links.get('instagram', '')
        current_youtube = social_links.get('youtube', '')
        current_tiktok = social_links.get('tiktok', '')
        modal = LinksUpdateModal(current_instagram, current_youtube, current_tiktok)
        await interaction.response.send_modal(modal)

    @discord.ui.button(label='Tema', style=discord.ButtonStyle.secondary, emoji='üé≠', row=1)
    async def change_theme(self, interaction: discord.Interaction, button: discord.ui.Button):
        if str(interaction.user.id) != self.user_id:
            await interaction.response.send_message("‚ùå Este menu n√£o √© seu!", ephemeral=True)
            return
        
        embed = discord.Embed(
            title="üé≠ Escolher Tema do Perfil",
            description="Selecione um tema para personalizar a apar√™ncia do seu perfil:",
            color=user_data[self.user_id].get('profile_color', 0x9932CC)
        )
        
        embed.add_field(
            name="üé® Temas Dispon√≠veis",
            value="üåü **Cl√°ssico** - Elegante e atemporal\nüî• **Gamer** - Para os viciados em jogos\nüíº **Profissional** - S√©rio e corporativo\nüé® **Artista** - Criativo e colorido\nüå∏ **Kawaii** - Fofo e ador√°vel",
            inline=False
        )
        
        embed.add_field(
            name="üåà Temas Especiais",
            value="üñ§ **Dark Mode** - Escuro e minimalista\nüåà **Pride** - Colorido e inclusivo\n‚ö° **Neon** - Vibrante e futur√≠stico\nüåø **Natural** - Verde e org√¢nico\nüëë **Luxo** - Dourado e premium",
            inline=False
        )
        
        view = ThemeSelectView(self.user_id)
        await interaction.response.edit_message(embed=embed, view=view)

    @discord.ui.button(label='üèÜ Badge', style=discord.ButtonStyle.secondary, emoji='üèÜ', row=1)
    async def change_badge(self, interaction: discord.Interaction, button: discord.ui.Button):
        if str(interaction.user.id) != self.user_id:
            await interaction.response.send_message("‚ùå Este menu n√£o √© seu!", ephemeral=True)
            return
        
        embed = discord.Embed(
            title="üèÜ Escolher Badge do Perfil",
            description="Selecione um badge para mostrar sua personalidade:",
            color=user_data[self.user_id].get('profile_color', 0x9932CC)
        )
        
        embed.add_field(
            name="üéØ Badges Dispon√≠veis",
            value="üéÆ **Gamer** - Para os viciados em jogos\nüé® **Artista** - Para os criativos\nüìö **Estudante** - Para quem ama estudar\nüíº **Trabalhador** - Para os profissionais\nüåü **Streamer** - Para criadores de conte√∫do",
            inline=False
        )
        
        embed.add_field(
            name="üåü Mais Badges",
            value="üéµ **M√∫sico** - Para os amantes da m√∫sica\nüì∑ **Fot√≥grafo** - Para quem ama fotografar\n‚öΩ **Esportista** - Para os atletas\nüçï **Foodie** - Para os amantes da comida\nüåç **Viajante** - Para os exploradores",
            inline=False
        )
        
        view = BadgeSelectView(self.user_id)
        await interaction.response.edit_message(embed=embed, view=view)

    @discord.ui.button(label='Cor', style=discord.ButtonStyle.secondary, emoji='üé®', row=1)
    async def change_color(self, interaction: discord.Interaction, button: discord.ui.Button):
        if str(interaction.user.id) != self.user_id:
            await interaction.response.send_message("‚ùå Este menu n√£o √© seu!", ephemeral=True)
            return
        
        embed = discord.Embed(
            title="üé® Escolher Cor do Perfil",
            description="Selecione uma cor para personalizar seus embeds de perfil:",
            color=user_data[self.user_id].get('profile_color', 0x9932CC)
        )
        
        embed.add_field(
            name="üåà Cores Dispon√≠veis",
            value="üîµ **Azul Marinho** - Elegante e profissional\n‚ö´ **Cinza Escuro** - S√≥brio e moderno\nüü¢ **Verde Escuro** - Natural e confi√°vel\nüî∑ **Azul Petr√≥leo** - Sofisticado e √∫nico\nüç∑ **Vinho** - Luxuoso e marcante",
            inline=False
        )
        
        embed.add_field(
            name="üéÄ Cores Vibrantes",
            value="üå∏ **Rosa Claro** - Doce e delicado\nüíú **Lavanda** - Suave e relaxante\nü™∏ **Coral** - Energ√©tico e caloroso\n‚òÅÔ∏è **Azul C√©u** - Fresco e livre\nü¶Ñ **Lil√°s** - M√°gico e criativo",
            inline=False
        )
        
        view = ColorSelectView(self.user_id)
        await interaction.response.edit_message(embed=embed, view=view)

class ProfileView(discord.ui.View):
    def __init__(self, user_id, member):
        super().__init__(timeout=300)
        self.user_id = user_id
        self.member = member

    @discord.ui.button(label='Mudar Imagem', style=discord.ButtonStyle.secondary, emoji='üñºÔ∏è')
    async def change_image(self, interaction: discord.Interaction, button: discord.ui.Button):
        user_id = str(interaction.user.id)

        embed = discord.Embed(
            title="üñºÔ∏è Escolha o Tipo de Imagem",
            description="Selecione qual tipo de imagem voc√™ deseja alterar:",
            color=0x9932CC
        )
        embed.add_field(
            name="üì∏ Thumbnail",
            value="Imagem pequena que aparece ao lado do nome",
            inline=True
        )
        embed.add_field(
            name="üñºÔ∏è Imagem do Embed",
            value="Imagem grande que aparece no perfil",
            inline=True
        )

        view = ImageTypeView(user_id)
        await interaction.response.send_message(embed=embed, view=view, ephemeral=True)

    

# Sistema de dados dos usu√°rios (em mem√≥ria - em produ√ß√£o use banco de dados)
user_data = {}

# Sistema de relacionamentos sociais
follow_data = {
    # "user_id": {
    #     "following": ["user_id1", "user_id2"],  # quem o usu√°rio segue
    #     "followers": ["user_id3", "user_id4"]   # quem segue o usu√°rio
    # }
}

# Sistema de rastreamento de resets (quem j√° usou o comando m!reset)
reset_data = {
    # "user_id": True  # True = j√° usou o reset
}

# Sistema de economia (dinheiro e fama)
economy_data = {
    # "user_id": {
    #     "money": 0,    # Dinheiro em reais
    #     "fame": 0      # Pontos de fama ganhos com publicidade
    # }
}

# Sistema de tracking de posts com marcas (para evitar spam de m!publi)
brand_posts_data = {
    # "user_id": {
    #     "message_123456": {
    #         "brands": ["Nike", "Adidas"],
    #         "rewarded": False,
    #         "timestamp": "2024-01-01T12:00:00"
    #     }
    # }
}

# Sistema de invent√°rio dos usu√°rios
inventory_data = {
    # "user_id": {
    #     "carros": [{"nome": "BMW M3", "preco": 50000, "data_compra": "2024-01-01"}],
    #     "mansoes": [],
    #     "itens_diarios": []
    # }
}

# Cat√°logo da lojinha
LOJA_ITEMS = {
    "carros": {
        "üöó Volkswagen Gol": {"preco": 35000, "categoria": "Carros Populares"},
        "üöô Honda Civic": {"preco": 85000, "categoria": "Carros M√©dios"},
        "üöò Toyota Corolla": {"preco": 95000, "categoria": "Carros M√©dios"},
        "üöó Hyundai HB20": {"preco": 65000, "categoria": "Carros Populares"},
        "üöô Nissan Sentra": {"preco": 88000, "categoria": "Carros M√©dios"},
        "üèéÔ∏è BMW M3": {"preco": 250000, "categoria": "Carros Esportivos"},
        "üèéÔ∏è Audi RS4": {"preco": 280000, "categoria": "Carros Esportivos"},
        "üèéÔ∏è Porsche 911": {"preco": 350000, "categoria": "Carros Esportivos"},
        "üöò Mercedes-Benz C-Class": {"preco": 320000, "categoria": "Carros Luxo"},
        "üöò BMW S√©rie 5": {"preco": 380000, "categoria": "Carros Luxo"},
        "üöò Audi A6": {"preco": 360000, "categoria": "Carros Luxo"},
        "üî• Lamborghini Hurac√°n": {"preco": 1200000, "categoria": "Supercars"},
        "üî• Ferrari F8": {"preco": 1400000, "categoria": "Supercars"},
        "üî• McLaren 570S": {"preco": 900000, "categoria": "Supercars"},
        "üëë Bugatti Chiron": {"preco": 15000000, "categoria": "Hipercars"},
        "üëë Koenigsegg Agera": {"preco": 12000000, "categoria": "Hipercars"},
        "‚ö° Tesla Model S": {"preco": 450000, "categoria": "Carros El√©tricos"},
        "‚ö° Tesla Model 3": {"preco": 280000, "categoria": "Carros El√©tricos"},
        "‚ö° BMW iX": {"preco": 520000, "categoria": "Carros El√©tricos"},
        "üåü Ferrari 488": {"preco": 1800000, "categoria": "Supercars"},
        "üíé Rolls-Royce Phantom": {"preco": 2500000, "categoria": "Ultra Luxo"},
        "üíé Bentley Mulsanne": {"preco": 1800000, "categoria": "Ultra Luxo"},
        "üöÄ McLaren 720S": {"preco": 1500000, "categoria": "Supercars"}
    },
    "mansoes": {
        "üè† Casa Simples": {"preco": 150000, "categoria": "Resid√™ncias B√°sicas"},
        "üè† Apartamento Studio": {"preco": 80000, "categoria": "Resid√™ncias B√°sicas"},
        "üè† Casa Geminada": {"preco": 120000, "categoria": "Resid√™ncias B√°sicas"},
        "üè° Casa de Classe M√©dia": {"preco": 500000, "categoria": "Resid√™ncias M√©dias"},
        "üè° Sobrado": {"preco": 650000, "categoria": "Resid√™ncias M√©dias"},
        "üè° Casa com Piscina": {"preco": 750000, "categoria": "Resid√™ncias M√©dias"},
        "üèòÔ∏è Casa de Luxo": {"preco": 1200000, "categoria": "Resid√™ncias de Luxo"},
        "üèòÔ∏è Casa no Condom√≠nio": {"preco": 1500000, "categoria": "Resid√™ncias de Luxo"},
        "üèòÔ∏è Casa com Vista": {"preco": 1800000, "categoria": "Resid√™ncias de Luxo"},
        "üè∞ Mans√£o Cl√°ssica": {"preco": 5000000, "categoria": "Mans√µes"},
        "üè∞ Mans√£o Moderna": {"preco": 6000000, "categoria": "Mans√µes"},
        "üè∞ Mans√£o Vitoriana": {"preco": 7500000, "categoria": "Mans√µes"},
        "üå¥ Mans√£o na Praia": {"preco": 8000000, "categoria": "Mans√µes Premium"},
        "üå¥ Casa de Praia": {"preco": 4500000, "categoria": "Mans√µes Premium"},
        "üèîÔ∏è Chal√© nas Montanhas": {"preco": 3500000, "categoria": "Propriedades Especiais"},
        "üèîÔ∏è Cabana Alpina": {"preco": 2800000, "categoria": "Propriedades Especiais"},
        "üåÜ Penthouse": {"preco": 6500000, "categoria": "Apartamentos de Luxo"},
        "üåÜ Cobertura Duplex": {"preco": 5200000, "categoria": "Apartamentos de Luxo"},
        "üèõÔ∏è Mans√£o Hist√≥rica": {"preco": 12000000, "categoria": "Propriedades √önicas"},
        "üèõÔ∏è Castelo Medieval": {"preco": 15000000, "categoria": "Propriedades √önicas"},
        "üåü Mans√£o dos Sonhos": {"preco": 25000000, "categoria": "Ultra Premium"},
        "üåü Villa Italiana": {"preco": 30000000, "categoria": "Ultra Premium"},
        "üëë Pal√°cio Real": {"preco": 50000000, "categoria": "Realeza"},
        "üëë Pal√°cio de Versalhes": {"preco": 100000000, "categoria": "Realeza"}
    },
    "itens_diarios": {
        "‚òï Caf√© Starbucks": {"preco": 15, "categoria": "Bebidas"},
        "‚òï Cappuccino": {"preco": 12, "categoria": "Bebidas"},
        "ü•§ Coca-Cola": {"preco": 8, "categoria": "Bebidas"},
        "ü•§ Red Bull": {"preco": 18, "categoria": "Bebidas"},
        "ü•§ √Ågua Mineral": {"preco": 5, "categoria": "Bebidas"},
        "üçî Big Mac": {"preco": 25, "categoria": "Comidas"},
        "üçï Pizza Grande": {"preco": 45, "categoria": "Comidas"},
        "üçó KFC Bucket": {"preco": 55, "categoria": "Comidas"},
        "üåÆ Taco Bell": {"preco": 20, "categoria": "Comidas"},
        "üçú Ramen": {"preco": 30, "categoria": "Comidas"},
        "üëï Camiseta Nike": {"preco": 120, "categoria": "Roupas"},
        "üëï Camiseta Adidas": {"preco": 110, "categoria": "Roupas"},
        "üëñ Cal√ßa Jeans": {"preco": 180, "categoria": "Roupas"},
        "üß• Jaqueta Couro": {"preco": 450, "categoria": "Roupas"},
        "üëó Vestido": {"preco": 200, "categoria": "Roupas"},
        "üëü T√™nis Adidas": {"preco": 350, "categoria": "Cal√ßados"},
        "üëü T√™nis Nike": {"preco": 380, "categoria": "Cal√ßados"},
        "üëû Sapato Social": {"preco": 280, "categoria": "Cal√ßados"},
        "üì± iPhone 15": {"preco": 8500, "categoria": "Eletr√¥nicos"},
        "üì± Samsung Galaxy": {"preco": 6500, "categoria": "Eletr√¥nicos"},
        "üíª MacBook Pro": {"preco": 15000, "categoria": "Eletr√¥nicos"},
        "üíª Dell Inspiron": {"preco": 4500, "categoria": "Eletr√¥nicos"},
        "üì∫ TV 75\" OLED": {"preco": 18000, "categoria": "Eletr√¥nicos"},
        "üì∫ TV 55\" 4K": {"preco": 3500, "categoria": "Eletr√¥nicos"},
        "üéß AirPods Pro": {"preco": 2200, "categoria": "Eletr√¥nicos"},
        "üéß Fone JBL": {"preco": 800, "categoria": "Eletr√¥nicos"},
        "üéÆ PlayStation 5": {"preco": 4500, "categoria": "Games"},
        "üéÆ Xbox Series X": {"preco": 4200, "categoria": "Games"},
        "üéÆ Nintendo Switch": {"preco": 2800, "categoria": "Games"},
        "‚åö Apple Watch": {"preco": 3500, "categoria": "Acess√≥rios"},
        "‚åö Smartwatch Samsung": {"preco": 1800, "categoria": "Acess√≥rios"},
        "üï∂Ô∏è √ìculos Ray-Ban": {"preco": 800, "categoria": "Acess√≥rios"},
        "üï∂Ô∏è √ìculos Oakley": {"preco": 650, "categoria": "Acess√≥rios"},
        "‚åö Rolex": {"preco": 85000, "categoria": "Joias"},
        "üëú Bolsa Louis Vuitton": {"preco": 12000, "categoria": "Acess√≥rios de Luxo"},
        "üëú Bolsa Gucci": {"preco": 8500, "categoria": "Acess√≥rios de Luxo"},
        "üíç Anel de Diamante": {"preco": 25000, "categoria": "Joias"},
        "üíç Anel de Ouro": {"preco": 3500, "categoria": "Joias"},
        "üíé Colar de P√©rolas": {"preco": 15000, "categoria": "Joias"}
    }
}

# Biblioteca extensa de marcas famosas para detec√ß√£o de publicidade
FAMOUS_BRANDS = [
    # Tecnologia
    "Apple", "Microsoft", "Google", "Samsung", "Sony", "LG", "Xiaomi", "Huawei", 
    "Intel", "AMD", "NVIDIA", "Tesla", "SpaceX", "Meta", "Facebook", 
    "Twitter", "TikTok", "YouTube", "Netflix", "Amazon", "Spotify", "Discord",
    "WhatsApp", "Telegram", "LinkedIn", "Snapchat", "Pinterest", "Reddit",
    "Adobe", "Oracle", "IBM", "HP", "Dell", "Lenovo", "Asus", "Acer",
    "OnePlus", "Realme", "Oppo", "Vivo", "Motorola", "Nokia", "BlackBerry",
    
    # Esportes e Vestu√°rio
    "Nike", "Adidas", "Puma", "Under Armour", "Reebok", "Converse", "Vans",
    "New Balance", "Jordan", "Supreme", "Off-White", "Balenciaga", "Gucci",
    "Louis Vuitton", "Prada", "Versace", "Armani", "Calvin Klein", "Tommy Hilfiger",
    "Lacoste", "Polo Ralph Lauren", "Hugo Boss", "Diesel", "Levi's", "Gap",
    "H&M", "Zara", "Uniqlo", "Forever 21", "Victoria's Secret", "Chanel",
    
    # Alimenta√ß√£o e Bebidas
    "Coca-Cola", "Pepsi", "McDonald's", "KFC", "Burger King", "Subway",
    "Pizza Hut", "Domino's", "Starbucks", "Red Bull", "Monster Energy",
    "Nestl√©", "Ferrero", "Mars", "Hershey's", "Cadbury", "Oreo", "Pringles",
    "Lay's", "Doritos", "Cheetos", "Skittles", "M&M's", "Snickers",
    "Kit Kat", "Nutella", "Kinder", "Heinz", "Ketchup", "Maggi",
    
    # Autom√≥veis
    "Toyota", "Ford", "Chevrolet", "BMW", "Mercedes-Benz", "Audi", "Volkswagen",
    "Honda", "Nissan", "Hyundai", "Kia", "Mazda", "Subaru", "Mitsubishi",
    "Lexus", "Infiniti", "Acura", "Porsche", "Ferrari", "Lamborghini",
    "Bentley", "Rolls-Royce", "Maserati", "Bugatti", "McLaren", "Aston Martin",
    "Jaguar", "Land Rover", "Volvo", "MINI", "Fiat", "Alfa Romeo",
    
    # Cosm√©ticos e Beleza
    "L'Or√©al", "Maybelline", "MAC", "Sephora", "Avon", "Revlon", "CoverGirl",
    "Est√©e Lauder", "Clinique", "Lanc√¥me", "Dior", "Chanel", "YSL", "Fenty Beauty",
    "Rare Beauty", "Glossier", "Urban Decay", "Too Faced", "Benefit", "NARS",
    "Bobbi Brown", "Shiseido", "Kiehl's", "The Body Shop", "Bath & Body Works",
    
    # Varejo e E-commerce
    "Amazon", "eBay", "Alibaba", "Walmart", "Target", "Best Buy", "IKEA",
    "Home Depot", "Costco", "Sears", "Macy's", "Nordstrom", "Zara", "H&M",
    "Forever 21", "Urban Outfitters", "American Eagle", "Hollister", "Abercrombie",
    
    # Entretenimento e M√≠dia
    "Disney", "Warner Bros", "Universal Studios", "Paramount", "Sony Pictures",
    "Marvel", "DC Comics", "HBO", "Showtime", "ESPN", "CNN", "BBC", "Fox",
    "MTV", "VH1", "Comedy Central", "Cartoon Network", "Nickelodeon",
    
    # Jogos
    "PlayStation", "Xbox", "Nintendo", "Steam", "Epic Games", "Riot Games",
    "Blizzard", "Activision", "EA Games", "Ubisoft", "Rockstar Games",
    "Valve", "Bethesda", "2K Games", "Square Enix", "Capcom", "Konami",
    "Sega", "Bandai Namco", "CD Projekt", "Mojang", "Minecraft", "Fortnite",
    "League of Legends", "World of Warcraft", "Call of Duty", "FIFA", "GTA",
    
    # Bancos e Finan√ßas
    "Visa", "Mastercard", "American Express", "PayPal", "Bitcoin", "Ethereum",
    "JPMorgan Chase", "Bank of America", "Wells Fargo", "Goldman Sachs",
    "Morgan Stanley", "Citibank", "HSBC", "Deutsche Bank", "Credit Suisse",
    
    # Marcas Brasileiras
    "Globo", "SBT", "Record", "Band", "Bradesco", "Ita√∫", "Banco do Brasil",
    "Caixa", "Santander", "Nubank", "Inter", "C6 Bank", "PicPay", "Mercado Pago",
    "Magazine Luiza", "Casas Bahia", "Lojas Americanas", "Submarino", "Mercado Livre",
    "Natura", "O Botic√°rio", "Avon", "Eudora", "Quem Disse Berenice",
    "Petrobras", "Vale", "JBS", "Ambev", "Braskem", "Embraer",
    "Gol", "Azul", "LATAM", "Uber", "99", "iFood", "Rappi", "Z√© Delivery",
    "Ifood", "Magalu", "B2W", "Via Varejo", "Renner", "Riachuelo", "C&A",
    "Hering", "Osklen", "Farm", "Animale", "Shoulder", "Ellus", "Colcci",
    "Havaianas", "Melissa", "Grendha", "Ipanema", "Rider", "Kenner",
    "Guaran√° Antarctica", "Brahma", "Skol", "Heineken", "Corona", "Stella Artois",
    "Budweiser", "Sprite", "Fanta", "Schweppes", "Dolly", "Sukita",
    "Shein", "AliExpress", "Shopee", "Wish", "Temu", "Romwe", "Zaful",
    "McDonald", "Burger", "Pizza", "KFC", "Subway", "Coca", "Pepsi",
    
    # Streaming e Entretenimento
    "Netflix", "Amazon Prime", "Disney+", "HBO Max", "Paramount+", "Apple TV+",
    "Hulu", "Peacock", "Discovery+", "Pluto TV", "Tubi", "Crunchyroll",
    "Globoplay", "Telecine", "Paramount+", "Star+", "Claro Video",
    
    # Redes Sociais Adicionais
    "OnlyFans", "Twitch", "Patreon", "Clubhouse", "BeReal", "VSCO",
    "Tumblr", "Flickr", "Vimeo", "Dailymotion", "WeChat", "Line",
    
    # Marcas de Luxo
    "Rolex", "Cartier", "Tiffany & Co", "Bulgari", "Herm√®s", "Burberry",
    "Moschino", "Dolce & Gabbana", "Saint Laurent", "Givenchy", "Valentino",
    "Tom Ford", "Bottega Veneta", "Celine", "Loewe", "Jacquemus"
]

def save_user_data():
    """Salva os dados dos usu√°rios no MongoDB"""
    try:
        if db is None:
            print("‚ùå MongoDB n√£o conectado - salvamento cancelado")
            return
        
        collection = db.user_data
        
        if user_data:
            # Salva cada usu√°rio individualmente usando discord_id como chave prim√°ria
            documents_saved = 0
            for user_id, data in user_data.items():
                try:
                    # Cria documento com discord_id como _id
                    doc = data.copy()
                    doc['_id'] = user_id  # Usa discord_id como _id principal
                    doc['updated_at'] = datetime.datetime.utcnow()
                    
                    # Usa upsert para evitar conflitos
                    result = collection.replace_one(
                        {'_id': user_id}, 
                        doc, 
                        upsert=True
                    )
                    
                    documents_saved += 1
                    username = data.get('username', 'sem_nome')
                    followers = data.get('followers', 0)
                    print(f"üíæ Salvou: {user_id} -> @{username} ({followers} seguidores)")
                    
                except Exception as doc_error:
                    print(f"‚ùå Erro ao salvar usu√°rio {user_id}: {doc_error}")
                    continue
            
            print(f"‚úÖ MongoDB: {documents_saved}/{len(user_data)} usu√°rios salvos com sucesso!")
            
            # Confirma dados salvos
            saved_count = collection.count_documents({})
            print(f"üîç Total no MongoDB: {saved_count} documentos")
            
        else:
            print("‚ö†Ô∏è Nenhum dado de usu√°rio para salvar")
        
    except Exception as e:
        print(f"‚ùå Erro geral no save_user_data: {str(e)}")
        import traceback
        traceback.print_exc()

def save_follow_data():
    """Salva os dados de relacionamentos no MongoDB"""
    try:
        if db is None:
            print("‚ùå Conex√£o com MongoDB n√£o estabelecida")
            return
        
        collection = db.follow_data
        collection.delete_many({})
        
        if follow_data:
            documents = []
            for user_id, data in follow_data.items():
                doc = data.copy()
                doc['_id'] = user_id
                doc['updated_at'] = datetime.datetime.utcnow()
                documents.append(doc)
            
            collection.insert_many(documents)
        
        print(f"‚úÖ Dados de relacionamentos salvos no MongoDB! Total: {len(follow_data)}")
    except Exception as e:
        print(f"‚ùå Erro ao salvar dados de relacionamentos no MongoDB: {e}")

def save_reset_data():
    """Salva os dados de resets no MongoDB"""
    try:
        if db is None:
            return
        
        collection = db.reset_data
        collection.delete_many({})
        
        if reset_data:
            documents = []
            for user_id, used in reset_data.items():
                documents.append({
                    '_id': user_id,
                    'used_reset': used,
                    'updated_at': datetime.datetime.utcnow()
                })
            
            collection.insert_many(documents)
        
        print(f"‚úÖ Dados de reset salvos no MongoDB! Total: {len(reset_data)}")
    except Exception as e:
        print(f"‚ùå Erro ao salvar dados de reset no MongoDB: {e}")

def save_economy_data():
    """Salva os dados de economia no MongoDB"""
    try:
        if db is None or not economy_data:
            return
        
        collection = db.economy_data
        collection.delete_many({})
        
        documents = []
        for user_id, data in economy_data.items():
            doc = data.copy()
            doc['_id'] = user_id
            doc['updated_at'] = datetime.datetime.utcnow()
            documents.append(doc)
        
        collection.insert_many(documents)
    except Exception as e:
        pass  # Silencioso

def save_brand_posts_data():
    """Salva os dados de posts com marcas no MongoDB"""
    try:
        if db is None:
            return
        
        collection = db.brand_posts_data
        collection.delete_many({})
        
        if brand_posts_data:
            documents = []
            for user_id, posts in brand_posts_data.items():
                documents.append({
                    '_id': user_id,
                    'posts': posts,
                    'updated_at': datetime.datetime.utcnow()
                })
            
            collection.insert_many(documents)
        
        print(f"‚úÖ Dados de posts com marcas salvos no MongoDB! Total: {len(brand_posts_data)}")
    except Exception as e:
        print(f"‚ùå Erro ao salvar dados de posts no MongoDB: {e}")

def save_inventory_data():
    """Salva os dados de invent√°rio no MongoDB"""
    try:
        if db is None:
            return
        
        collection = db.inventory_data
        collection.delete_many({})
        
        if inventory_data:
            documents = []
            for user_id, data in inventory_data.items():
                doc = data.copy()
                doc['_id'] = user_id
                doc['updated_at'] = datetime.datetime.utcnow()
                documents.append(doc)
            
            collection.insert_many(documents)
        
        print(f"‚úÖ Dados de invent√°rio salvos no MongoDB! Total: {len(inventory_data)}")
    except Exception as e:
        print(f"‚ùå Erro ao salvar dados de invent√°rio no MongoDB: {e}")

def load_user_data():
    """Carrega os dados dos usu√°rios do MongoDB"""
    global user_data
    try:
        if db is None:
            print("‚ùå MongoDB n√£o conectado - carregamento cancelado")
            user_data = {}
            return
        
        collection = db.user_data
        document_count = collection.count_documents({})
        print(f"üîç MongoDB: Encontrados {document_count} documentos na cole√ß√£o user_data")
        
        documents = collection.find({})
        
        user_data = {}
        loaded_count = 0
        
        for doc in documents:
            try:
                discord_id = doc['_id']  # Agora _id √© sempre discord_id
                
                # Remove campos do MongoDB antes de salvar na mem√≥ria
                doc_clean = doc.copy()
                doc_clean.pop('_id', None)
                doc_clean.pop('updated_at', None)
                
                user_data[discord_id] = doc_clean
                loaded_count += 1
                
                username = doc_clean.get('username', 'sem_nome')
                followers = doc_clean.get('followers', 0)
                print(f"üì• Carregado: {discord_id} -> @{username} ({followers} seguidores)")
                
            except Exception as doc_error:
                print(f"‚ùå Erro ao carregar documento: {doc_error}")
                continue
        
        print(f"‚úÖ User data loaded: {loaded_count} users carregados com sucesso")
            
    except Exception as e:
        print(f"‚ùå Erro ao carregar do MongoDB: {str(e)}")
        import traceback
        traceback.print_exc()
        user_data = {}

def load_follow_data():
    """Carrega os dados de relacionamentos do MongoDB"""
    global follow_data
    try:
        if db is None:
            print("‚ùå Conex√£o com MongoDB n√£o estabelecida")
            follow_data = {}
            return
        
        collection = db.follow_data
        documents = collection.find({})
        
        follow_data = {}
        for doc in documents:
            user_id = doc['_id']
            doc.pop('_id', None)
            doc.pop('updated_at', None)
            follow_data[user_id] = doc
        
        print(f"‚úÖ Dados de relacionamentos carregados do MongoDB! Total: {len(follow_data)}")
    except Exception as e:
        print(f"‚ùå Erro ao carregar dados de relacionamentos do MongoDB: {e}")
        follow_data = {}

def load_reset_data():
    """Carrega os dados de resets do MongoDB"""
    global reset_data
    try:
        if db is None:
            reset_data = {}
            return
        
        collection = db.reset_data
        documents = collection.find({})
        
        reset_data = {}
        for doc in documents:
            user_id = doc['_id']
            reset_data[user_id] = doc.get('used_reset', True)
        
        print(f"‚úÖ Dados de reset carregados do MongoDB! Total: {len(reset_data)}")
    except Exception as e:
        print(f"‚ùå Erro ao carregar dados de reset do MongoDB: {e}")
        reset_data = {}

def load_economy_data():
    """Carrega os dados de economia do MongoDB"""
    global economy_data
    try:
        if db is None:
            print("‚ùå Conex√£o com MongoDB n√£o estabelecida")
            economy_data = {}
            return
        
        collection = db.economy_data
        documents = collection.find({})
        
        economy_data = {}
        for doc in documents:
            user_id = doc['_id']
            doc.pop('_id', None)
            doc.pop('updated_at', None)
            economy_data[user_id] = doc
        
        print(f"‚úÖ Dados de economia carregados do MongoDB! Total: {len(economy_data)}")
    except Exception as e:
        print(f"‚ùå Erro ao carregar dados de economia do MongoDB: {e}")
        economy_data = {}

def load_brand_posts_data():
    """Carrega os dados de posts com marcas do MongoDB"""
    global brand_posts_data
    try:
        if db is None:
            brand_posts_data = {}
            return
        
        collection = db.brand_posts_data
        documents = collection.find({})
        
        brand_posts_data = {}
        for doc in documents:
            user_id = doc['_id']
            brand_posts_data[user_id] = doc.get('posts', {})
        
        print(f"‚úÖ Dados de posts carregados do MongoDB! Total: {len(brand_posts_data)}")
    except Exception as e:
        print(f"‚ùå Erro ao carregar dados de posts do MongoDB: {e}")
        brand_posts_data = {}

def load_inventory_data():
    """Carrega os dados de invent√°rio do MongoDB"""
    global inventory_data
    try:
        if db is None:
            inventory_data = {}
            return
        
        collection = db.inventory_data
        documents = collection.find({})
        
        inventory_data = {}
        for doc in documents:
            user_id = doc['_id']
            doc.pop('_id', None)
            doc.pop('updated_at', None)
            inventory_data[user_id] = doc
        
        print(f"‚úÖ Dados de invent√°rio carregados do MongoDB! Total: {len(inventory_data)}")
    except Exception as e:
        print(f"‚ùå Erro ao carregar dados de invent√°rio do MongoDB: {e}")
        inventory_data = {}

# Configura√ß√£o do bot
intents = discord.Intents.default()
intents.message_content = True
bot = commands.Bot(command_prefix='m!', intents=intents)

# --- CONFIGURA√á√ïES MODIFICADAS ---

# 1. Emojis que ser√£o adicionados √†s mensagens
EMOJIS = [
    "<:mxplike1:1381003788135174316>"
]

# 2. IDs dos canais onde o bot deve reagir.
#    O bot S√ì vai funcionar nestes canais.
ALLOWED_CHANNEL_IDS = [
    1375957391706689690,
    1375957390062780604,
    1375957388498047046
]

# --- FIM DAS CONFIGURA√á√ïES ---

@bot.event
async def on_ready():
    print(f'‚úÖ {bot.user} est√° online!')
    print(f'üì° Bot configurado para reagir nos canais: {ALLOWED_CHANNEL_IDS}')
    
    # Inicializa dados globais primeiro
    global user_data, follow_data, reset_data, economy_data, brand_posts_data, inventory_data
    user_data = {}
    follow_data = {}
    reset_data = {}
    economy_data = {}
    brand_posts_data = {}
    inventory_data = {}
    
    # Inicia sistemas em background primeiro (para o bot funcionar imediatamente)
    try:
        rotate_status.start()
        auto_save.start()
        print("‚úÖ Sistemas auxiliares iniciados!")
    except Exception as e:
        print(f"‚ö†Ô∏è Erro sistemas: {e}")
    
    print("üöÄ Bot operacional!")
    
    # Conecta MongoDB de forma ass√≠ncrona em background (n√£o bloqueia o bot)
    async def connect_mongodb():
        await asyncio.sleep(2)  # Espera 2 segundos antes de tentar
        try:
            print("üîÑ Conectando MongoDB em background...")
            if init_mongodb():
                load_user_data()
                load_follow_data()
                load_reset_data()
                load_economy_data()
                load_brand_posts_data()
                load_inventory_data()
                print("‚úÖ MongoDB conectado e dados carregados!")
            else:
                print("‚ö†Ô∏è MongoDB indispon√≠vel - usando dados locais")
        except Exception as e:
            print(f"‚ö†Ô∏è Erro MongoDB: {str(e)[:50]} - continuando sem BD")
    
    # Executa conex√£o MongoDB em background
    asyncio.create_task(connect_mongodb())

@tasks.loop(minutes=3)  # Auto-save a cada 3 minutos (mais frequente)
async def auto_save():
    """Salva automaticamente todos os dados a cada 3 minutos"""
    if db is None:
        return  # N√£o faz nada se MongoDB n√£o estiver conectado
    
    try:
        save_user_data()
        save_economy_data()
        save_follow_data()
        save_brand_posts_data()
        save_inventory_data()
        save_reset_data()
        print(f"üíæ Auto-save executado em {datetime.datetime.now().strftime('%H:%M:%S')}")
    except Exception as e:
        print(f"‚ùå Erro no auto-save: {e}")

# Sistema de status rotativo com dicas de comandos
from discord.ext import tasks

@tasks.loop(minutes=3)  # Mudou para 3 minutos para reduzir spam
async def rotate_status():
    """Rotaciona o status do bot com dicas de comandos"""
    status_list = [
        "üéØ Use m!ajudainsta para ver comandos!",
        "üë§ Use m!perfil para ver seu Instagram!",
        "üìä Use m!seguidores para se registrar!",
        "üèÜ Use m!curtidas para ver ranking!",
        "üë• Use m!seguir @usuario para seguir!",
        "üìù Use m!atualizar para editar perfil!",
        "üíñ Reaja nas mensagens para curtir!",
        "üì± Simule Instagram no Discord!"
    ]

    import random
    status = random.choice(status_list)
    try:
        await bot.change_presence(
            activity=discord.Game(name=status)
        )
    except Exception as e:
        pass  # Ignora erros de status silenciosamente

@bot.event
async def on_message(message):
    # Ignora mensagens do pr√≥prio bot
    if message.author == bot.user:
        return

    # 3. VERIFICA SE A MENSAGEM EST√Å EM UM CANAL PERMITIDO
    if message.channel.id in ALLOWED_CHANNEL_IDS:
        try:
            # Adiciona cada emoji na ordem especificada
            for emoji in EMOJIS:
                await message.add_reaction(emoji)
            print(f'Emojis adicionados √† mensagem de {message.author} no canal #{message.channel.name}')
            
            # SISTEMA DE DETEC√á√ÉO AUTOM√ÅTICA DE PUBLICIDADE (igual ao m!publi mas autom√°tico)
            user_id = str(message.author.id)
            
            # Verifica se o usu√°rio est√° registrado
            if user_id in user_data:
                message_content = message.content.lower()
                detected_brands = []
                
                # Procura por marcas famosas na mensagem (detec√ß√£o simplificada e mais eficaz)
                import re
                
                print(f"üîç Analisando mensagem: '{message.content}'")
                print(f"üîç Texto em min√∫sculas: '{message_content}'")
                
                for brand in FAMOUS_BRANDS:
                    brand_lower = brand.lower()
                    
                    # M√©todo mais simples e eficaz - busca direta na string
                    if brand_lower in message_content:
                        # Verifica se n√£o √© parte de outra palavra (opcional)
                        # Usa regex simples apenas para verificar se √© palavra completa
                        word_pattern = r'\b' + re.escape(brand_lower) + r'\b'
                        
                        # Primeiro tenta match exato (palavra completa)
                        if re.search(word_pattern, message_content, re.IGNORECASE):
                            if brand not in detected_brands:
                                detected_brands.append(brand)
                                print(f"‚úÖ Marca detectada (palavra completa): {brand}")
                        # Se n√£o encontrou como palavra completa, aceita como substring
                        elif brand_lower in message_content:
                            if brand not in detected_brands:
                                detected_brands.append(brand)
                                print(f"‚úÖ Marca detectada (substring): {brand}")
                
                # Log para debug
                print(f"üìù Analisando: {message.author.display_name} ({len(message.content)} chars)")
                print(f"üìù Mensagem completa: '{message.content}'")
                print(f"üìù Usu√°rio registrado: {user_id in user_data}")
                print(f"üìù Marcas detectadas: {detected_brands}")
                print(f"üìù Tamanho da mensagem: {len(message.content)} chars (m√≠nimo: 40)")
                
                # RESPOSTA AUTOM√ÅTICA IGUAL AO m!publi (sem comando necess√°rio)
                if detected_brands and len(message.content) >= 40:
                    message_id = str(message.id)
                    
                    # Inicializa dados se necess√°rio
                    if user_id not in brand_posts_data:
                        brand_posts_data[user_id] = {}
                    
                    if user_id not in economy_data:
                        economy_data[user_id] = {"money": 0, "fame": 0}
                    
                    # Evita spam - s√≥ recompensa uma vez por post
                    if message_id not in brand_posts_data[user_id]:
                        # C√ÅLCULO DE RECOMPENSAS (igual ao sistema do m!publi)
                        base_money = random.randint(2000, 8000)  # Base melhorada
                        brand_multiplier = len(detected_brands) * 300  # B√¥nus por marca
                        
                        # B√¥nus especial por marcas populares
                        premium_brands = ["Apple", "Nike", "Coca-Cola", "Samsung", "Google", "Microsoft", "Amazon"]
                        premium_bonus = sum(500 for brand in detected_brands if brand in premium_brands)
                        
                        total_money = base_money + brand_multiplier + premium_bonus
                        
                        # Fama baseada nos seguidores atuais
                        current_followers = user_data[user_id].get('followers', 0)
                        base_fame = int(current_followers * 0.01)  # 1% dos seguidores
                        
                        # B√¥nus de fama por m√∫ltiplas marcas
                        if len(detected_brands) > 1:
                            base_fame = int(base_fame * (1 + (len(detected_brands) - 1) * 0.15))
                        
                        # B√¥nus extra para mensagens mais longas (conte√∫do de qualidade)
                        if len(message.content) >= 100:
                            length_bonus = int(total_money * 0.2)
                            total_money += length_bonus
                            base_fame = int(base_fame * 1.3)
                        
                        # ATUALIZA OS DADOS
                        economy_data[user_id]["money"] += total_money
                        economy_data[user_id]["fame"] += base_fame
                        user_data[user_id]['followers'] += base_fame  # Seguidores ganhos
                        
                        # Registra o post como recompensado
                        import datetime
                        brand_posts_data[user_id][message_id] = {
                            "brands": detected_brands,
                            "rewarded": True,
                            "timestamp": datetime.datetime.now().isoformat(),
                            "content_preview": message.content[:100],
                            "money_gained": total_money,
                            "fame_gained": base_fame,
                            "is_premium": any(brand in premium_brands for brand in detected_brands)
                        }
                        
                        # Salva tudo
                        save_economy_data()
                        save_user_data()
                        save_brand_posts_data()
                        
                        # RESPOSTA AUTOM√ÅTICA ESTILIZADA (igual ao m!publi)
                        main_brand = detected_brands[0]
                        is_premium = main_brand in premium_brands
                        
                        embed = discord.Embed(
                            title="üéØ Patroc√≠nio Registrado Automaticamente!" if not is_premium else "‚≠ê Patroc√≠nio Premium Registrado!",
                            description=f"**{message.author.display_name}** fez uma publicidade para **{main_brand}**{' e outras marcas' if len(detected_brands) > 1 else ''}!\n\n‚úÖ **Patroc√≠nio detectado e registrado com sucesso!**",
                            color=0x00FF00 if not is_premium else 0xFFD700
                        )
                        
                        # Mostra ganhos detalhados
                        money_details = f"**R$ {total_money:,}**".replace(",", ".")
                        if brand_multiplier > 0:
                            money_details += f"\n+R$ {brand_multiplier:,} (b√¥nus marcas)".replace(",", ".")
                        if premium_bonus > 0:
                            money_details += f"\n+R$ {premium_bonus:,} (marcas premium)".replace(",", ".")
                        
                        embed.add_field(
                            name="ü§ë Dinheiro Ganho",
                            value=money_details,
                            inline=True
                        )
                        
                        embed.add_field(
                            name="üìà Seguidores Ganhos",
                            value=f"**+{base_fame:,}** seguidores".replace(",", "."),
                            inline=True
                        )
                        
                        # Saldo total atualizado
                        embed.add_field(
                            name="üí∞ Saldo Total",
                            value=f"üíµ R$ {economy_data[user_id]['money']:,}\nüë• {user_data[user_id]['followers']:,} seguidores\n‚≠ê {economy_data[user_id]['fame']:,} pontos de fama".replace(",", "."),
                            inline=False
                        )
                        
                        # Lista todas as marcas se m√∫ltiplas
                        if len(detected_brands) > 1:
                            brands_text = ", ".join(detected_brands)
                            embed.add_field(
                                name="üè∑Ô∏è Todas as Marcas Detectadas",
                                value=f"{brands_text} ({len(detected_brands)} marcas)",
                                inline=False
                            )
                        
                        # B√¥nus especiais
                        bonuses = []
                        if len(message.content) >= 100:
                            bonuses.append("üìù Conte√∫do longo (+30% b√¥nus)")
                        if is_premium:
                            bonuses.append("‚≠ê Marca premium detectada")
                        if len(detected_brands) >= 3:
                            bonuses.append("üî• M√∫ltiplas marcas (+50% fama)")
                            
                        if bonuses:
                            embed.add_field(
                                name="üéâ B√¥nus Especiais",
                                value="\n".join(bonuses),
                                inline=False
                            )
                        
                        embed.set_thumbnail(url="https://cdn.discordapp.com/emojis/1381003788135174316.png")
                        embed.set_footer(
                            text="ü§ñ Sistema Autom√°tico ‚Ä¢ Patroc√≠nio detectado e registrado instantaneamente!",
                            icon_url=message.author.display_avatar.url
                        )
                        
                        # Responde ao post automaticamente e agenda para deletar em 15 segundos
                        response_message = await message.reply(embed=embed)
                        
                        # Agenda a exclus√£o da mensagem ap√≥s 15 segundos
                        async def delete_after_delay():
                            await asyncio.sleep(15)
                            try:
                                await response_message.delete()
                                print(f"üíº Embed de patroc√≠nio deletado automaticamente: {message.author.display_name}")
                            except discord.NotFound:
                                print(f"‚ö†Ô∏è Mensagem j√° foi deletada: {message.author.display_name}")
                            except discord.Forbidden:
                                print(f"‚ùå Sem permiss√£o para deletar mensagem: {message.author.display_name}")
                            except Exception as e:
                                print(f"‚ùå Erro ao deletar embed: {e}")
                        
                        # Executa a fun√ß√£o de delay em background
                        asyncio.create_task(delete_after_delay())
                        
                        print(f"üíº Publicidade autom√°tica processada: {message.author.display_name} | +R${total_money} +{base_fame} seguidores | Marcas: {detected_brands}")
                    
                    else:
                        print(f"üîÑ Post j√° recompensado: {message.author.display_name}")
                
                # Logs informativos para debug
                elif detected_brands and len(message.content) < 40:
                    print(f"‚ùå Marcas encontradas mas texto muito curto ({len(message.content)} chars): {message.author.display_name}")
                    print(f"‚ùå Marcas encontradas: {detected_brands}")
                elif len(message.content) >= 40 and not detected_brands:
                    print(f"‚ÑπÔ∏è Texto longo mas sem marcas: {message.author.display_name}")
                    print(f"‚ÑπÔ∏è Algumas marcas para teste: Nike, Apple, Coca-Cola est√£o na mensagem? {any(brand.lower() in message_content for brand in ['Nike', 'Apple', 'Coca-Cola'])}")
                elif not detected_brands and len(message.content) < 40:
                    print(f"‚ÑπÔ∏è Mensagem normal: {message.author.display_name}")
                    
                # Teste adicional para debug
                test_brands = ['Nike', 'Apple', 'Coca-Cola', 'Instagram', 'McDonald']
                found_test = [brand for brand in test_brands if brand.lower() in message_content]
                if found_test:
                    print(f"üß™ TESTE: Marcas encontradas manualmente: {found_test}")
                    
        except discord.HTTPException as e:
            # Este erro pode acontecer se o bot n√£o tiver acesso ao emoji (n√£o est√° no servidor)
            # ou n√£o tiver permiss√£o para adicionar rea√ß√µes.
            print(f'Erro ao adicionar emoji: {e}')
        except Exception as e:
            print(f'Erro inesperado: {e}')

    # Processa outros comandos do bot (como m!teste) em qualquer canal
    await bot.process_commands(message)

@bot.event
async def on_reaction_add(reaction, user):
    """Rastreia quando algu√©m adiciona uma rea√ß√£o"""
    # Ignora rea√ß√µes do pr√≥prio bot
    if user == bot.user:
        return

    # Verifica se a rea√ß√£o √© um dos emojis do Instagram
    if str(reaction.emoji) in EMOJIS:
        # Pega o ID do autor da mensagem original
        message_author_id = str(reaction.message.author.id)

        # Inicializa dados do usu√°rio se n√£o existir
        if message_author_id not in user_data:
            user_data[message_author_id] = {
                'username': None,
                'total_likes': 0,
                'posts_count': 0,
                'followers': 0,
                'profession': None,
                'thumbnail_url': None,
                'embed_image_url': None
            }

        # Adiciona uma curtida
        user_data[message_author_id]['total_likes'] += 1

        # Verifica se a curtida foi no canal espec√≠fico (1375957388498047046)
        if reaction.message.channel.id == 1375957388498047046:
            current_followers = user_data[message_author_id]['followers']
            
            # Calcula 0.5% dos seguidores atuais
            if current_followers > 0:
                followers_gain = int(current_followers * 0.005)  # 0.5% = 0.005
                
                # Adiciona os seguidores ganhos
                user_data[message_author_id]['followers'] += followers_gain
                
                print(f"üéâ {reaction.message.author} ganhou {followers_gain:,} seguidores! (0.5% de {current_followers:,})")
                print(f"   Total de seguidores agora: {user_data[message_author_id]['followers']:,}")

        # Salva os dados imediatamente
        save_user_data()
        print(f"üíæ Curtida salva no MongoDB para {reaction.message.author}")

        print(f"Curtida adicionada para {reaction.message.author}. Total: {user_data[message_author_id]['total_likes']}")

@bot.event
async def on_reaction_remove(reaction, user):
    """Rastreia quando algu√©m remove uma rea√ß√£o"""
    # Ignora rea√ß√µes do pr√≥prio bot
    if user == bot.user:
        print(f"Ignorando remo√ß√£o de rea√ß√£o do pr√≥prio bot")
        return

    # Verifica se a mensagem est√° em um canal permitido
    if reaction.message.channel.id not in ALLOWED_CHANNEL_IDS:
        print(f"Rea√ß√£o removida em canal n√£o permitido: #{reaction.message.channel.name}")
        return

    print(f"üîç Rea√ß√£o removida detectada: {reaction.emoji} por {user} na mensagem de {reaction.message.author}")

    # Verifica se a rea√ß√£o √© um dos emojis do Instagram
    if str(reaction.emoji) in EMOJIS:
        # Pega o ID do autor da mensagem original
        message_author_id = str(reaction.message.author.id)

        print(f"‚úÖ Emoji v√°lido detectado. Processando remo√ß√£o para usu√°rio ID: {message_author_id}")

        # Se o usu√°rio existe nos dados
        if message_author_id in user_data:
            likes_antes = user_data[message_author_id]['total_likes']

            # Remove uma curtida (m√≠nimo 0)
            user_data[message_author_id]['total_likes'] = max(0, user_data[message_author_id]['total_likes'] - 1)

            # Verifica se a curtida removida foi no canal espec√≠fico (1375957388498047046)
            if reaction.message.channel.id == 1375957388498047046:
                current_followers = user_data[message_author_id]['followers']
                
                # Calcula 0.5% dos seguidores atuais para remover
                if current_followers > 0:
                    followers_loss = int(current_followers * 0.005)  # 0.5% = 0.005
                    
                    # Remove os seguidores (m√≠nimo 0)
                    user_data[message_author_id]['followers'] = max(0, user_data[message_author_id]['followers'] - followers_loss)
                    
                    print(f"üìâ {reaction.message.author} perdeu {followers_loss:,} seguidores pela remo√ß√£o da curtida!")
                    print(f"   Total de seguidores agora: {user_data[message_author_id]['followers']:,}")

            likes_depois = user_data[message_author_id]['total_likes']

            # Salva os dados
            save_user_data()

            print(f"‚úÖ Curtida removida de {reaction.message.author.display_name}!")
            print(f"   Likes antes: {likes_antes} ‚Üí Likes depois: {likes_depois}")
            print(f"   Total atual: {user_data[message_author_id]['total_likes']} curtidas")
        else:
            print(f"‚ùå Tentativa de remover curtida de usu√°rio n√£o registrado: {reaction.message.author.display_name} (ID: {message_author_id})")
    else:
        print(f"‚ùå Rea√ß√£o removida n√£o √© do tipo Instagram: {reaction.emoji}")

# Comando de teste
@bot.command(name='teste')
async def teste(ctx):
    await ctx.reply('Bot est√° funcionando!')

# Comando de seguidores do Instagram
@bot.command(name='seguidores')
async def seguidores(ctx):
    user_id = str(ctx.author.id)

    # Inicializa dados do usu√°rio se n√£o existir
    if user_id not in user_data:
        user_data[user_id] = {
            'username': None,
            'total_likes': 0,
            'posts_count': 0,
            'followers': 0,
            'profession': None,
            'thumbnail_url': None,
            'embed_image_url': None
        }

    # Verifica se o usu√°rio j√° tem seguidores (j√° usou o comando)
    if user_data[user_id]['followers'] > 0:
        followers_atual = user_data[user_id]['followers']
        followers_formatado = f"{followers_atual:,}".replace(",", ".")

        embed = discord.Embed(
            title="‚ùå Comando j√° utilizado!",
            description=f"Voc√™ j√° possui **{followers_formatado}** seguidores permanentes.",
            color=0xFF0000
        )
        embed.add_field(
            name="‚ÑπÔ∏è Informa√ß√£o",
            value="O comando `m!seguidores` s√≥ pode ser usado uma vez por pessoa.",
            inline=False
        )
        embed.set_thumbnail(url=ctx.author.display_avatar.url)
        embed.set_footer(text=f"Solicitado por {ctx.author.display_name}")

        await ctx.reply(embed=embed)
        return

    # ID do dono do bot (substitua pelo seu ID do Discord)
    OWNER_ID = "983196900910039090"  # Substitua pelo seu ID do Discord
    
    # ID especial que sempre ter√° 2 seguidores
    SPECIAL_ID = "1380743682944139265"

    # Verifica se √© o dono do bot
    if user_id == OWNER_ID:
        num_seguidores = 250000000  # 25 milh√µes fixos para o dono
        # Define curtidas e dados especiais para o owner
        user_data[user_id]['total_likes'] = 15000  # 15k curtidas fixas
    elif user_id == SPECIAL_ID:
        num_seguidores = 120000000  # Sempre 2 seguidores para este ID espec√≠fico
    else:
        # Gera n√∫mero aleat√≥rio de seguidores entre 20.000 e 2.000.000
        num_seguidores = random.randint(20000, 2000000)

    # Salva o n√∫mero de seguidores para o usu√°rio
    user_data[user_id]['followers'] = num_seguidores
    user_data[user_id]['username'] = ctx.author.display_name  # Garante que username est√° definido
    
    print(f"üîç DEBUG: Salvando usu√°rio {user_id} com {num_seguidores} seguidores e username '{ctx.author.display_name}'")
    save_user_data()
    print(f"üíæ Dados de registro salvos para: {ctx.author.display_name}")

    # Calcula pontos de fama por like baseado na quantidade de seguidores
    if user_id == SPECIAL_ID:
        pontos_por_like = 1  # Pontos muito baixos para quem tem apenas 2 seguidores
    elif num_seguidores >= 800000:
        pontos_por_like = random.randint(80, 100)
    elif num_seguidores >= 600000:
        pontos_por_like = random.randint(60, 79)
    elif num_seguidores >= 400000:
        pontos_por_like = random.randint(45, 59)
    elif num_seguidores >= 200000:
        pontos_por_like = random.randint(30, 44)
    elif num_seguidores >= 100000:
        pontos_por_like = random.randint(20, 29)
    elif num_seguidores >= 50000:
        pontos_por_like = random.randint(15, 19)
    else:
        pontos_por_like = random.randint(10, 14)

    # Formata o n√∫mero de seguidores com pontos
    seguidores_formatado = f"{num_seguidores:,}".replace(",", ".")

    # Define o username automaticamente como o display name do Discord
    user_data[user_id]['username'] = ctx.author.display_name

    # Verifica n√≠veis de verifica√ß√£o baseado nos seguidores
    username_display = ctx.author.display_name
    if user_id == OWNER_ID:
        username_display = f"{username_display} <:extremomxp:1387842927602172125>"
    elif user_id == SPECIAL_ID:
        username_display = f"{username_display}"  # Sem verifica√ß√£o para quem tem apenas 2 seguidores
    elif num_seguidores >= 1000000:
        username_display = f"{username_display} <:abudabimxp:1387843390506405922>"
    elif num_seguidores >= 500000:
        username_display = f"{username_display} <:verificadomxp:1387605173886783620>"
    else:
        username_display = f"{username_display} <:verificiadinmxp:1387842858912055428>"

    # Cria o embed
    embed = discord.Embed(
        title="üìä Estat√≠sticas do Instagram",
        description=f"Informa√ß√µes do perfil de {username_display}",
        color=0xE4405F  # Cor do Instagram
    )

    embed.add_field(
        name=f"<:membromxp:1384773599046537257> Seguidores",
        value=f"**{seguidores_formatado}** seguidores",
        inline=False
    )

    embed.add_field(
        name="‚≠ê Pontos de Fama por Like",
        value=f"**{pontos_por_like}** pontos por like",
        inline=False
    )

    # Adiciona informa√ß√£o extra baseada na quantidade de seguidores
    if num_seguidores >= 25000000:
        status = "üëë **DONO DO BOT!** Perfil supremo!"
    elif user_id == SPECIAL_ID:
        status = "üòÖ **PERFIL ESPECIAL!** Come√ßando humildemente!"
    elif num_seguidores >= 800000:
        status = "üî• **MEGA VIRAL!** Perfil lend√°rio!"
    elif num_seguidores >= 500000:
        status = "‚úÖ **VERIFICADO!** Perfil oficial!"
    elif num_seguidores >= 200000:
        status = "üöÄ **VIRAL!** Perfil em alta!"
    elif num_seguidores >= 100000:
        status = "üìà **CRESCENDO RAPIDAMENTE!**"
    elif num_seguidores >= 50000:
        status = "‚≠ê **BOM CRESCIMENTO!**"
    else:
        status = "üå± **INICIANTE PROMISSOR!**"

    embed.add_field(
        name="üìä Status",
        value=status,
        inline=False
    )

    embed.set_footer(text=f"Comandado por {ctx.author.display_name}")
    embed.set_thumbnail(url="https://upload.wikimedia.org/wikipedia/commons/thumb/a/a5/Instagram_icon.png/1024px-Instagram_icon.png")

    print(f"‚úÖ Seguidores salvos para {ctx.author.display_name}: {num_seguidores}")

    view = ProfileView(user_id, ctx.author)
    await ctx.reply(embed=embed, view=view)



# Comando de perfil
@bot.command(name='perfil')
async def perfil(ctx, member: discord.Member = None):
    # Se n√£o especificar membro, mostra o pr√≥prio perfil
    if member is None:
        member = ctx.author

    user_id = str(member.id)

    # Verifica se o usu√°rio tem dados
    if user_id not in user_data:
        if member == ctx.author:
            embed = discord.Embed(
                title="‚ùå Registro Necess√°rio",
                description="Voc√™ precisa se registrar antes de usar o perfil!",
                color=0xFF0000
            )
            embed.add_field(
                name="üìù Como se registrar:",
                value="Use o comando `m!seguidores` para criar seu perfil",
                inline=False
            )
            await ctx.reply(embed=embed)
        else:
            await ctx.reply(f"‚ùå {member.display_name} ainda n√£o se registrou!")
        return

    # Se chegou at√© aqui, o usu√°rio est√° registrado e tem username
    user_info = user_data[user_id]
    username = user_info['username']
    total_likes = user_info.get('total_likes', 0)
    followers = user_info.get('followers', 0)

    # Adiciona verifica√ß√£o baseada nos n√≠veis de seguidores
    username_display = username
    if user_id == "983196900910039090":  # Owner ID
        username_display = f"{username} <:extremomxp:1387842927602172125>"
    elif followers >= 1000000:
        username_display = f"{username} <:abudabimxp:1387843390506405922>"
    elif followers >= 500000:
        username_display = f"{username} <:verificadomxp:1387605173886783620>"
    else:
        username_display = f"{username} <:verificiadinmxp:1387842858912055428>"

    # Calcula level baseado nas curtidas (especial para o owner)
    if user_id == "983196900910039090":  # Owner ID
        level = 500  # Level fixo 500 para o dono
        status = "üëë **LENDA GLOBAL!**"
        cor = user_info.get('profile_color', 0xFFD700)  # Usa cor personalizada ou dourado para lenda
    else:
        level = min(total_likes // 10, 100)  # 1 level a cada 10 curtidas, m√°ximo 100
        
        # Define status baseado nas curtidas
        if total_likes >= 500:
            status = "üî• **INFLUENCER!**"
        elif total_likes >= 200:
            status = "‚≠ê **POPULAR!**"
        elif total_likes >= 100:
            status = "üìà **EM ALTA!**"
        elif total_likes >= 50:
            status = "üåü **CRESCENDO!**"
        else:
            status = "üå± **INICIANTE**"
        
        # Usa cor personalizada do usu√°rio ou cor padr√£o
        cor = user_info.get('profile_color', 0x9932CC)

    # Cria o embed do perfil
    embed = discord.Embed(
        title=f"üì± Perfil do Instagram",
        description=f"Perfil de **{username_display}**",
        color=cor
    )

    embed.add_field(
        name="üë§ Nome de Usu√°rio",
        value=f"@{username_display}",
        inline=True
    )

    embed.add_field(
        name=f"<:mxplike1:1381003788135174316> Total de Curtidas",
        value=f"**{total_likes:,}** curtidas".replace(",", "."),
        inline=True
    )

    embed.add_field(
        name="<:coroamxp:1376731577106567319> Level",
        value=f"**Level {level}**",
        inline=True
    )

    # Adiciona campo de profiss√£o se existir
    profession = user_info.get('profession')
    if profession:
        embed.add_field(
            name="<:profmxp:1387539539169509456> Profiss√£o",
            value=f"**{profession}**",
            inline=True
        )

    # Adiciona badge se existir
    profile_badge = user_info.get('profile_badge')
    if profile_badge:
        badge_names = {
            "gamer": "üéÆ Gamer", "artista": "üé® Artista", "estudante": "üìö Estudante",
            "trabalhador": "üíº Trabalhador", "streamer": "üåü Streamer", "musico": "üéµ M√∫sico",
            "fotografo": "üì∑ Fot√≥grafo", "esportista": "‚öΩ Esportista", "foodie": "üçï Foodie", "viajante": "üåç Viajante"
        }
        badge_name = badge_names.get(profile_badge, "üèÜ Especial")
        embed.add_field(
            name="üèÜ Badge",
            value=f"**{badge_name}**",
            inline=True
        )

    # Adiciona campo de seguidores se existir
    followers = user_info.get('followers', 0)
    if followers > 0:
        followers_formatado = f"{followers:,}".replace(",", ".")
        embed.add_field(
            name=f"<:membromxp:1384773599046537257> Seguidores",
            value=f"**{followers_formatado}** seguidores",
            inline=True
        )

    # Adiciona campo de seguidores reais (famosos)
    real_followers = follow_data.get(user_id, {}).get("followers", [])
    real_followers_count = len(real_followers)
    embed.add_field(
        name=f"<:reaismxp:1387842813084831936> Seguidores Famosos",
        value=f"**{real_followers_count}** seguidores reais",
        inline=True
    )

    # Adiciona bio se existir
    bio = user_info.get('bio')
    if bio:
        embed.add_field(
            name="üìù Bio",
            value=f"*{bio}*",
            inline=False
        )

    # Adiciona status se existir
    status = user_info.get('status')
    if status:
        embed.add_field(
            name="üí´ Status",
            value=f"**{status}**",
            inline=False
        )

    # Adiciona links sociais se existirem
    social_links = user_info.get('social_links', {})
    if any(social_links.values()):
        links_text = ""
        if social_links.get('instagram'): 
            links_text += f"üì∑ **Instagram:** {social_links['instagram']}\n"
        if social_links.get('youtube'): 
            links_text += f"<:youtubemxp:1388210526202495116> **YouTube:** {social_links['youtube']}\n"
        if social_links.get('tiktok'): 
            links_text += f"<:mxptiktok:1381007602892275824> **TikTok:** {social_links['tiktok']}\n"
        
        if links_text:
            embed.add_field(
                name="üîó Links Sociais",
                value=links_text.strip(),
                inline=False
            )

    embed.add_field(
        name=f"<:mxpinstagram:1381002235462287452> Status",
        value=status,
        inline=False
    )

    # Adiciona barra de progresso para o pr√≥ximo level (n√£o para o owner)
    if user_id != "983196900910039090":  # N√£o mostra progresso para o owner (j√° √© level m√°ximo)
        progress_to_next = (total_likes % 10) * 10  # Porcentagem para pr√≥ximo level
        progress_bar = "‚ñì" * (progress_to_next // 10) + "‚ñë" * (10 - (progress_to_next // 10))

        embed.add_field(
            name="üìà Progresso para pr√≥ximo level",
            value=f"`{progress_bar}` {total_likes % 10}/10",
            inline=False
        )
    else:
        embed.add_field(
            name="üëë Status de Lenda",
            value="**Level m√°ximo atingido!** Voc√™ √© uma lenda no Instagram MXP!",
            inline=False
        )

    # Define thumbnail (personalizada ou avatar padr√£o)
    thumbnail_url = user_info.get('thumbnail_url')
    if thumbnail_url:
        embed.set_thumbnail(url=thumbnail_url)
    else:
        embed.set_thumbnail(url=member.display_avatar.url)

    # Define imagem do embed se personalizada
    embed_image_url = user_info.get('embed_image_url')
    if embed_image_url:
        embed.set_image(url=embed_image_url)

    # Footer com informa√ß√µes extras
    if member == ctx.author:
        footer_text = f"ID: {member.id} ‚Ä¢ Use m!atualizar para editar nome/profiss√£o"
    else:
        footer_text = f"ID: {member.id} ‚Ä¢ Perfil visualizado por {ctx.author.display_name}"

    embed.set_footer(
        text=footer_text,
        icon_url=ctx.author.display_avatar.url
    )

    view = ProfileView(user_id, member)
    await ctx.reply(embed=embed, view=view)

# Comando para ver ranking de curtidas
@bot.command(name='curtidas')
async def curtidas(ctx):
    # Ordena usu√°rios por curtidas
    sorted_users = sorted(user_data.items(), key=lambda x: x[1]['total_likes'], reverse=True)

    if not sorted_users:
        await ctx.reply("‚ùå Nenhum usu√°rio encontrado no ranking!")
        return

    embed = discord.Embed(
        title="üèÜ Ranking de Curtidas",
        description="Top usu√°rios com mais curtidas",
        color=0xFFD700
    )

    # Mostra top 10
    for i, (user_id, data) in enumerate(sorted_users[:10]):
        try:
            user = bot.get_user(int(user_id))
            username = data.get('username', 'Sem nome')
            likes = data.get('total_likes', 0)

            if user:
                if i == 0:
                    medal = "ü•á"
                elif i == 1:
                    medal = "ü•à"
                elif i == 2:
                    medal = "ü•â"
                else:
                    medal = f"{i+1}¬∫"

                embed.add_field(
                    name=f"{medal} @{username}",
                    value=f"<:mxplike1:1381003788135174316> **{likes:,}** curtidas".replace(",", "."),
                    inline=False
                )
        except:
            continue

    await ctx.reply(embed=embed)

# Comando para migrar dados JSON para MongoDB (apenas para o dono)
@bot.command(name='migrar_dados')
async def migrar_dados(ctx):
    # S√≥ o dono do bot pode usar
    if str(ctx.author.id) != "983196900910039090":
        await ctx.reply("‚ùå Apenas o dono do bot pode usar este comando!")
        return
    
    if db is None:
        await ctx.reply("‚ùå Conex√£o com MongoDB n√£o estabelecida!")
        return
    
    embed = discord.Embed(
        title="üîÑ Migrando Dados para MongoDB",
        description="Iniciando migra√ß√£o dos arquivos JSON...",
        color=0xFFD700
    )
    await ctx.reply(embed=embed)
    
    try:
        # Carrega dados dos arquivos JSON existentes
        migrated_collections = []
        
        # Migra user_data
        try:
            with open('user_data.json', 'r') as f:
                json_user_data = json.load(f)
            if json_user_data:
                collection = db.user_data
                collection.delete_many({})
                documents = []
                for user_id, data in json_user_data.items():
                    doc = data.copy()
                    doc['_id'] = user_id
                    doc['migrated_at'] = datetime.datetime.utcnow()
                    documents.append(doc)
                collection.insert_many(documents)
                migrated_collections.append(f"‚úÖ user_data: {len(documents)} documentos")
        except FileNotFoundError:
            migrated_collections.append("‚ö†Ô∏è user_data: arquivo n√£o encontrado")
        except Exception as e:
            migrated_collections.append(f"‚ùå user_data: erro - {str(e)[:50]}")
        
        # Migra economy_data
        try:
            with open('economy_data.json', 'r') as f:
                json_economy_data = json.load(f)
            if json_economy_data:
                collection = db.economy_data
                collection.delete_many({})
                documents = []
                for user_id, data in json_economy_data.items():
                    doc = data.copy()
                    doc['_id'] = user_id
                    doc['migrated_at'] = datetime.datetime.utcnow()
                    documents.append(doc)
                collection.insert_many(documents)
                migrated_collections.append(f"‚úÖ economy_data: {len(documents)} documentos")
        except FileNotFoundError:
            migrated_collections.append("‚ö†Ô∏è economy_data: arquivo n√£o encontrado")
        except Exception as e:
            migrated_collections.append(f"‚ùå economy_data: erro - {str(e)[:50]}")
        
        # Migra follow_data
        try:
            with open('follow_data.json', 'r') as f:
                json_follow_data = json.load(f)
            if json_follow_data:
                collection = db.follow_data
                collection.delete_many({})
                documents = []
                for user_id, data in json_follow_data.items():
                    doc = data.copy()
                    doc['_id'] = user_id
                    doc['migrated_at'] = datetime.datetime.utcnow()
                    documents.append(doc)
                collection.insert_many(documents)
                migrated_collections.append(f"‚úÖ follow_data: {len(documents)} documentos")
        except FileNotFoundError:
            migrated_collections.append("‚ö†Ô∏è follow_data: arquivo n√£o encontrado")
        except Exception as e:
            migrated_collections.append(f"‚ùå follow_data: erro - {str(e)[:50]}")
        
        # Migra outros dados...
        # (brand_posts_data, inventory_data, etc.)
        
        # Recarrega dados do MongoDB
        load_user_data()
        load_economy_data()
        load_follow_data()
        load_brand_posts_data()
        load_inventory_data()
        load_reset_data()
        
        success_embed = discord.Embed(
            title="‚úÖ Migra√ß√£o Conclu√≠da!",
            description="Dados migrados do JSON para MongoDB com sucesso!",
            color=0x00FF00
        )
        
        success_embed.add_field(
            name="üìä Resultado da Migra√ß√£o",
            value="\n".join(migrated_collections),
            inline=False
        )
        
        success_embed.add_field(
            name="üîÑ Dados Recarregados",
            value=f"üë• {len(user_data)} usu√°rios\nüí∞ {len(economy_data)} economias\nü§ù {len(follow_data)} relacionamentos",
            inline=False
        )
        
        success_embed.set_footer(text="Migra√ß√£o realizada com sucesso!")
        await ctx.reply(embed=success_embed)
        
    except Exception as e:
        error_embed = discord.Embed(
            title="‚ùå Erro na Migra√ß√£o",
            description=f"Ocorreu um erro durante a migra√ß√£o: {str(e)}",
            color=0xFF0000
        )
        await ctx.reply(embed=error_embed)



# Comando para seguir usu√°rio
@bot.command(name='seguir')
async def seguir(ctx, member: discord.Member = None):
    if member is None:
        embed = discord.Embed(
            title="‚ùå Erro",
            description="Voc√™ precisa mencionar um usu√°rio para seguir!",
            color=0xFF0000
        )
        embed.add_field(
            name="üìù Uso correto:",
            value="`m!seguir @usuario`",
            inline=False
        )
        await ctx.reply(embed=embed)
        return

    follower_id = str(ctx.author.id)
    followed_id = str(member.id)

    # N√£o pode seguir a si mesmo
    if follower_id == followed_id:
        embed = discord.Embed(
            title="‚ùå A√ß√£o inv√°lida",
            description="Voc√™ n√£o pode seguir a si mesmo!",
            color=0xFF0000
        )
        await ctx.reply(embed=embed)
        return

    # Verifica se ambos os usu√°rios est√£o registrados
    if follower_id not in user_data:
        embed = discord.Embed(
            title="‚ùå Registro necess√°rio",
            description="Voc√™ precisa se registrar primeiro!",
            color=0xFF0000
        )
        embed.add_field(
            name="üìù Como se registrar:",
            value="Use o comando `m!seguidores` para criar seu perfil",
            inline=False
        )
        await ctx.reply(embed=embed)
        return

    if followed_id not in user_data:
        embed = discord.Embed(
            title="‚ùå Usu√°rio n√£o registrado",
            description=f"{member.display_name} ainda n√£o se registrou!",
            color=0xFF0000
        )
        await ctx.reply(embed=embed)
        return

    # Inicializa dados de relacionamento se n√£o existir
    if follower_id not in follow_data:
        follow_data[follower_id] = {"following": [], "followers": []}
    if followed_id not in follow_data:
        follow_data[followed_id] = {"following": [], "followers": []}

    # Verifica se j√° segue
    if followed_id in follow_data[follower_id]["following"]:
        embed = discord.Embed(
            title="‚ùå J√° seguindo",
            description=f"Voc√™ j√° segue {member.display_name}!",
            color=0xFF0000
        )
        await ctx.reply(embed=embed)
        return

    # Adiciona o relacionamento
    follow_data[follower_id]["following"].append(followed_id)
    follow_data[followed_id]["followers"].append(follower_id)

    save_follow_data()

    # RECOMPENSA ESPECIAL: Se seguiu o dono do bot, ganha 250k seguidores
    followers_bonus = 0
    if followed_id == "983196900910039090":  # ID do dono do bot
        followers_bonus = 250000
        user_data[follower_id]['followers'] += followers_bonus
        save_user_data()
        print(f"üéâ RECOMPENSA ESPECIAL: {ctx.author.display_name} ganhou {followers_bonus:,} seguidores por seguir o dono!")

    # Verifica se agora s√£o amigos m√∫tuos (se seguem mutuamente)
    is_mutual = followed_id in follow_data[follower_id]["following"] and follower_id in follow_data[followed_id]["following"]

    if followers_bonus > 0:
        # Embed especial para quem seguiu o dono do bot
        embed = discord.Embed(
            title="üëë RECOMPENSA ESPECIAL DO DONO!",
            description=f"**{ctx.author.display_name}** seguiu o **Dono do Bot** e recebeu uma recompensa √©pica!",
            color=0xFFD700  # Dourado para recompensa especial
        )
        embed.add_field(
            name="üéâ Recompensa Obtida",
            value=f"**+{followers_bonus:,}** seguidores extras por seguir o dono!".replace(",", "."),
            inline=False
        )
        embed.add_field(
            name="üëë Status Especial",
            value="Voc√™ agora faz parte do c√≠rculo VIP do dono do bot!",
            inline=False
        )
        embed.set_thumbnail(url="https://cdn.discordapp.com/emojis/1387842927602172125.png")
    elif is_mutual:
        # Embed especial para amigos m√∫tuos
        embed = discord.Embed(
            title="ü§ù Voc√™s agora s√£o amigos!",
            description=f"**{ctx.author.display_name}** e **{member.display_name}** agora se seguem mutuamente!",
            color=0xFF69B4  # Rosa para amizade
        )
        embed.add_field(
            name="üíï Amizade Confirmada",
            value="Voc√™s dois se seguem mutuamente e agora s√£o amigos no Instagram!",
            inline=False
        )
        embed.set_thumbnail(url="https://cdn.discordapp.com/emojis/1387605173886783620.png")  # Emoji de cora√ß√£o ou amizade
    else:
        # Embed normal
        embed = discord.Embed(
            title="‚úÖ Agora seguindo!",
            description=f"Voc√™ agora segue **{member.display_name}**!",
            color=0x00FF00
        )
        embed.set_thumbnail(url=member.display_avatar.url)

    # Estat√≠sticas atualizadas incluindo a recompensa
    stats_text = f"Voc√™ segue **{len(follow_data[follower_id]['following'])}** pessoas\n{member.display_name} tem **{len(follow_data[followed_id]['followers'])}** seguidores"
    
    if followers_bonus > 0:
        current_followers = user_data[follower_id]['followers']
        stats_text += f"\n\nüéâ **Seus seguidores agora:** {current_followers:,}".replace(",", ".")
        stats_text += f"\nüëë **Recompensa especial:** +{followers_bonus:,} seguidores!".replace(",", ".")
    
    embed.add_field(
        name="üìä Estat√≠sticas:",
        value=stats_text,
        inline=False
    )
    embed.set_footer(text=f"Comando usado por {ctx.author.display_name}")

    await ctx.reply(embed=embed)

# Comando para deixar de seguir usu√°rio
@bot.command(name='desseguir')
async def desseguir(ctx, member: discord.Member = None):
    if member is None:
        embed = discord.Embed(
            title="‚ùå Erro",
            description="Voc√™ precisa mencionar um usu√°rio para deixar de seguir!",
            color=0xFF0000
        )
        embed.add_field(
            name="üìù Uso correto:",
            value="`m!desseguir @usuario`",
            inline=False
        )
        await ctx.reply(embed=embed)
        return

    follower_id = str(ctx.author.id)
    followed_id = str(member.id)

    # N√£o pode deixar de seguir a si mesmo
    if follower_id == followed_id:
        embed = discord.Embed(
            title="‚ùå A√ß√£o inv√°lida",
            description="Voc√™ n√£o pode deixar de seguir a si mesmo!",
            color=0xFF0000
        )
        await ctx.reply(embed=embed)
        return

    # Verifica se o usu√°rio est√° registrado
    if follower_id not in user_data:
        embed = discord.Embed(
            title="‚ùå Registro necess√°rio",
            description="Voc√™ precisa se registrar primeiro!",
            color=0xFF0000
        )
        embed.add_field(
            name="üìù Como se registrar:",
            value="Use o comando `m!seguidores` para criar seu perfil",
            inline=False
        )
        await ctx.reply(embed=embed)
        return

    # Verifica se tem dados de relacionamento
    if follower_id not in follow_data or followed_id not in follow_data[follower_id]["following"]:
        embed = discord.Embed(
            title="‚ùå N√£o est√° seguindo",
            description=f"Voc√™ n√£o segue {member.display_name}!",
            color=0xFF0000
        )
        await ctx.reply(embed=embed)
        return

    # Remove o relacionamento
    follow_data[follower_id]["following"].remove(followed_id)
    if followed_id in follow_data:
        if follower_id in follow_data[followed_id]["followers"]:
            follow_data[followed_id]["followers"].remove(follower_id)

    save_follow_data()

    # Embed de sucesso
    embed = discord.Embed(
        title="‚úÖ Deixou de seguir!",
        description=f"Voc√™ deixou de seguir **{member.display_name}**!",
        color=0x00FF00
    )
    embed.set_thumbnail(url=member.display_avatar.url)
    embed.add_field(
        name="üìä Estat√≠sticas:",
        value=f"Voc√™ agora segue **{len(follow_data[follower_id]['following'])}** pessoas",
        inline=False
    )
    embed.set_footer(text=f"Comando usado por {ctx.author.display_name}")

    await ctx.reply(embed=embed)

# Comando para ver seguidores
@bot.command(name='seguidores_lista')
async def seguidores_lista(ctx, member: discord.Member = None):
    if member is None:
        member = ctx.author

    user_id = str(member.id)

    # Verifica se o usu√°rio est√° registrado
    if user_id not in user_data:
        if member == ctx.author:
            embed = discord.Embed(
                title="‚ùå Registro necess√°rio",
                description="Voc√™ precisa se registrar primeiro!",
                color=0xFF0000
            )
            embed.add_field(
                name="üìù Como se registrar:",
                value="Use o comando `m!seguidores` para criar seu perfil",
                inline=False
            )
            await ctx.reply(embed=embed)
        else:
            await ctx.reply(f"‚ùå {member.display_name} ainda n√£o se registrou!")
        return

    # Pega a lista de seguidores
    followers_list = follow_data.get(user_id, {}).get("followers", [])

    embed = discord.Embed(
        title=f"üë• Seguidores de {member.display_name}",
        color=0x1DA1F2
    )
    embed.set_thumbnail(url=member.display_avatar.url)

    if not followers_list:
        embed.description = f"**{member.display_name}** ainda n√£o tem seguidores."
    else:
        followers_text = ""
        for i, follower_id in enumerate(followers_list[:10]):  # Mostra at√© 10
            try:
                follower_user = bot.get_user(int(follower_id))
                if follower_user and follower_id in user_data:
                    username = user_data[follower_id].get('username', follower_user.display_name)
                    followers_text += f"{i+1}. **@{username}**\n"
            except:
                continue

        if followers_text:
            embed.add_field(
                name=f"üìã Lista de Seguidores ({len(followers_list)} total)",
                value=followers_text,
                inline=False
            )

        if len(followers_list) > 10:
            embed.add_field(
                name="‚ÑπÔ∏è Informa√ß√£o",
                value=f"Mostrando apenas os primeiros 10 de {len(followers_list)} seguidores.",
                inline=False
            )

    embed.set_footer(text=f"Consultado por {ctx.author.display_name}")
    await ctx.reply(embed=embed)

# Comando para ver quem est√° seguindo
@bot.command(name='seguindo')
async def seguindo(ctx, member: discord.Member = None):
    if member is None:
        member = ctx.author

    user_id = str(member.id)

    # Verifica se o usu√°rio est√° registrado
    if user_id not in user_data:
        if member == ctx.author:
            embed = discord.Embed(
                title="‚ùå Registro necess√°rio",
                description="Voc√™ precisa se registrar primeiro!",
                color=0xFF0000
            )
            embed.add_field(
                name="üìù Como se registrar:",
                value="Use o comando `m!seguidores` para criar seu perfil",
                inline=False
            )
            await ctx.reply(embed=embed)
        else:
            await ctx.reply(f"‚ùå {member.display_name} ainda n√£o se registrou!")
        return

    # Pega a lista de quem est√° seguindo
    following_list = follow_data.get(user_id, {}).get("following", [])

    embed = discord.Embed(
        title=f"üë§ {member.display_name} est√° seguindo",
        color=0x9146FF
    )
    embed.set_thumbnail(url=member.display_avatar.url)

    if not following_list:
        embed.description = f"**{member.display_name}** ainda n√£o segue ningu√©m."
    else:
        following_text = ""
        for i, following_id in enumerate(following_list[:10]):  # Mostra at√© 10
            try:
                following_user = bot.get_user(int(following_id))
                if following_user and following_id in user_data:
                    username = user_data[following_id].get('username', following_user.display_name)
                    # Adiciona verifica√ß√£o baseada nos n√≠veis de seguidores
                    followers_count = user_data[following_id].get('followers', 0)
                    if following_id == "983196900910039090":  # Owner ID
                        username += " <:extremomxp:1387842927602172125>"
                    elif followers_count >= 1000000:
                        username += " <:abudabimxp:1387843390506405922>"
                    elif followers_count >= 500000:
                        username += " <:verificadomxp:1387605173886783620>"
                    else:
                        username += " <:verificiadinmxp:1387842858912055428>"
                    following_text += f"{i+1}. **@{username}**\n"
            except:
                continue

        if following_text:
            embed.add_field(
                name=f"üìã Lista de Seguindo ({len(following_list)} total)",
                value=following_text,
                inline=False
            )

        if len(following_list) > 10:
            embed.add_field(
                name="‚ÑπÔ∏è Informa√ß√£o",
                value=f"Mostrando apenas os primeiros 10 de {len(following_list)} pessoas.",
                inline=False
            )

    embed.set_footer(text=f"Consultado por {ctx.author.display_name}")
    await ctx.reply(embed=embed)

# Comando para atualizar perfil (nome e profiss√£o) usando modal
@bot.command(name='atualizar')
async def atualizar(ctx):
    user_id = str(ctx.author.id)

    # Verifica se o usu√°rio est√° registrado
    if user_id not in user_data:
        embed = discord.Embed(
            title="‚ùå Registro necess√°rio",
            description="Voc√™ precisa se registrar primeiro!",
            color=0xFF0000
        )
        embed.add_field(
            name="üìù Como se registrar:",
            value="Use o comando `m!seguidores` para criar seu perfil",
            inline=False
        )
        await ctx.reply(embed=embed)
        return

    # Inicializa novos campos se n√£o existirem
    if 'bio' not in user_data[user_id]:
        user_data[user_id]['bio'] = None
    if 'status' not in user_data[user_id]:
        user_data[user_id]['status'] = None
    if 'profile_theme' not in user_data[user_id]:
        user_data[user_id]['profile_theme'] = 'classico'
    if 'profile_badge' not in user_data[user_id]:
        user_data[user_id]['profile_badge'] = None
    if 'social_links' not in user_data[user_id]:
        user_data[user_id]['social_links'] = {}

    # Pega os dados atuais do usu√°rio
    user_data_info = user_data[user_id]
    current_username = user_data_info.get('username', '')
    current_profession = user_data_info.get('profession', '')
    current_bio = user_data_info.get('bio', '')
    current_status = user_data_info.get('status', '')
    current_theme = user_data_info.get('profile_theme', 'classico')
    current_badge = user_data_info.get('profile_badge', None)
    
    embed = discord.Embed(
        title="‚öôÔ∏è Central de Personaliza√ß√£o",
        description="Personalize seu perfil do Instagram MXP com v√°rias op√ß√µes!",
        color=user_data_info.get('profile_color', 0x9932CC)
    )
    
    # Informa√ß√µes b√°sicas
    embed.add_field(
        name="üìã Informa√ß√µes B√°sicas",
        value=f"**Nome:** {current_username or 'N√£o definido'}\n**Profiss√£o:** {current_profession or 'N√£o definido'}",
        inline=False
    )
    
    # Bio e Status
    bio_text = current_bio[:50] + "..." if current_bio and len(current_bio) > 50 else current_bio or "N√£o definida"
    status_text = current_status or "N√£o definido"
    embed.add_field(
        name="üí≠ Bio e Status",
        value=f"**Bio:** {bio_text}\n**Status:** {status_text}",
        inline=False
    )
    
    # Tema e Badge
    theme_names = {
        "classico": "üåü Cl√°ssico", "gamer": "üî• Gamer", "profissional": "üíº Profissional",
        "artista": "üé® Artista", "kawaii": "üå∏ Kawaii", "dark": "üñ§ Dark Mode",
        "pride": "üåà Pride", "neon": "‚ö° Neon", "natural": "üåø Natural", "luxo": "üëë Luxo"
    }
    badge_names = {
        "gamer": "üéÆ Gamer", "artista": "üé® Artista", "estudante": "üìö Estudante",
        "trabalhador": "üíº Trabalhador", "streamer": "üåü Streamer", "musico": "üéµ M√∫sico",
        "fotografo": "üì∑ Fot√≥grafo", "esportista": "‚öΩ Esportista", "foodie": "üçï Foodie", "viajante": "üåç Viajante"
    }
    
    current_theme_name = theme_names.get(current_theme, "üåü Cl√°ssico")
    current_badge_name = badge_names.get(current_badge, "Nenhum") if current_badge else "Nenhum"
    
    embed.add_field(
        name="üé≠ Apar√™ncia",
        value=f"**Tema:** {current_theme_name}\n**Badge:** {current_badge_name}\n**Cor:** {get_color_name(user_data_info.get('profile_color', 0x9932CC))}",
        inline=False
    )
    
    # Links sociais
    social_links = user_data_info.get('social_links', {})
    links_text = ""
    if social_links.get('instagram'): links_text += f"üì∑ {social_links['instagram']}\n"
    if social_links.get('youtube'): links_text += f"üé• {social_links['youtube']}\n"
    if social_links.get('tiktok'): links_text += f"üéµ {social_links['tiktok']}\n"
    if not links_text: links_text = "Nenhum link definido"
    
    embed.add_field(
        name="üîó Links Sociais",
        value=links_text,
        inline=False
    )
    
    embed.add_field(
        name="‚ú® Op√ß√µes de Personaliza√ß√£o",
        value="**Nome/Profiss√£o** - Informa√ß√µes b√°sicas\n **Bio/Status** - Descri√ß√£o e status atual\n **Links Sociais** - Instagram, YouTube, TikTok\n **Tema** - Apar√™ncia do perfil\n **Badge** - Badge especial\n **Cor** - Cor dos embeds",
        inline=False
    )
    
    embed.set_thumbnail(url="https://cdn.discordapp.com/emojis/1387842927602172125.png")
    embed.set_footer(text="Use os bot√µes abaixo para personalizar seu perfil")

    # View com bot√µes de atualiza√ß√£o
    view = UpdateProfileView(current_username, current_profession, user_id)
    await ctx.reply(embed=embed, view=view)

# Classes para o sistema de lojinha
class LojaMainView(discord.ui.View):
    def __init__(self, user_id):
        super().__init__(timeout=300)
        self.user_id = user_id

    @discord.ui.button(label='üöó Carros', style=discord.ButtonStyle.primary, emoji='üöó')
    async def carros_button(self, interaction: discord.Interaction, button: discord.ui.Button):
        if str(interaction.user.id) != self.user_id:
            await interaction.response.send_message("‚ùå Esta loja n√£o √© sua!", ephemeral=True)
            return
        
        view = LojaCarrosView(self.user_id)
        embed = discord.Embed(
            title="üöó Carros Dispon√≠veis",
            description="Escolha a categoria de carros que deseja ver:",
            color=0x3498DB
        )
        embed.set_thumbnail(url="https://cdn.discordapp.com/emojis/1387842927602172125.png")
        await interaction.response.edit_message(embed=embed, view=view)

    @discord.ui.button(label='üè∞ Mans√µes', style=discord.ButtonStyle.secondary, emoji='üè∞')
    async def mansoes_button(self, interaction: discord.Interaction, button: discord.ui.Button):
        if str(interaction.user.id) != self.user_id:
            await interaction.response.send_message("‚ùå Esta loja n√£o √© sua!", ephemeral=True)
            return
        
        view = LojaMansoesView(self.user_id)
        embed = discord.Embed(
            title="üè∞ Mans√µes Dispon√≠veis",
            description="Escolha a categoria de mans√µes que deseja ver:",
            color=0xE67E22
        )
        embed.set_thumbnail(url="https://cdn.discordapp.com/emojis/1387842927602172125.png")
        await interaction.response.edit_message(embed=embed, view=view)

    @discord.ui.button(label='üõçÔ∏è Itens do Dia a Dia', style=discord.ButtonStyle.success, emoji='üõçÔ∏è')
    async def itens_button(self, interaction: discord.Interaction, button: discord.ui.Button):
        if str(interaction.user.id) != self.user_id:
            await interaction.response.send_message("‚ùå Esta loja n√£o √© sua!", ephemeral=True)
            return
        
        view = LojaItensView(self.user_id)
        embed = discord.Embed(
            title="üõçÔ∏è Itens do Dia a Dia",
            description="Escolha a categoria de itens que deseja ver:",
            color=0x27AE60
        )
        embed.set_thumbnail(url="https://cdn.discordapp.com/emojis/1387842927602172125.png")
        await interaction.response.edit_message(embed=embed, view=view)

    @discord.ui.button(label='üì¶ Meu Invent√°rio', style=discord.ButtonStyle.blurple, emoji='üì¶')
    async def inventario_button(self, interaction: discord.Interaction, button: discord.ui.Button):
        if str(interaction.user.id) != self.user_id:
            await interaction.response.send_message("‚ùå Esta loja n√£o √© sua!", ephemeral=True)
            return
        
        # Inicializa invent√°rio se n√£o existir
        if self.user_id not in inventory_data:
            inventory_data[self.user_id] = {"carros": [], "mansoes": [], "itens_diarios": []}
        
        user_inventory = inventory_data[self.user_id]
        
        embed = discord.Embed(
            title="üì¶ Meu Invent√°rio",
            description=f"Todos os seus itens comprados:",
            color=0x9B59B6
        )
        
        # Carros
        if user_inventory["carros"]:
            carros_text = ""
            for i, carro in enumerate(user_inventory["carros"][:5]):  # Mostra at√© 5
                carros_text += f"üöó **{carro['nome']}** - R$ {carro['preco']:,}\n".replace(",", ".")
            embed.add_field(
                name=f"üöó Carros ({len(user_inventory['carros'])})",
                value=carros_text,
                inline=False
            )
        
        # Mans√µes
        if user_inventory["mansoes"]:
            mansoes_text = ""
            for i, mansao in enumerate(user_inventory["mansoes"][:3]):  # Mostra at√© 3
                mansoes_text += f"üè∞ **{mansao['nome']}** - R$ {mansao['preco']:,}\n".replace(",", ".")
            embed.add_field(
                name=f"üè∞ Mans√µes ({len(user_inventory['mansoes'])})",
                value=mansoes_text,
                inline=False
            )
        
        # Itens do dia a dia
        if user_inventory["itens_diarios"]:
            itens_text = ""
            for i, item in enumerate(user_inventory["itens_diarios"][:8]):  # Mostra at√© 8
                itens_text += f"üõçÔ∏è **{item['nome']}** - R$ {item['preco']:,}\n".replace(",", ".")
            embed.add_field(
                name=f"üõçÔ∏è Itens do Dia a Dia ({len(user_inventory['itens_diarios'])})",
                value=itens_text,
                inline=False
            )
        
        if not any([user_inventory["carros"], user_inventory["mansoes"], user_inventory["itens_diarios"]]):
            embed.add_field(
                name="üò¢ Invent√°rio Vazio",
                value="Voc√™ ainda n√£o comprou nenhum item! Use os bot√µes acima para fazer compras.",
                inline=False
            )
        
        embed.set_footer(text="Use os bot√µes para navegar pela loja")
        await interaction.response.edit_message(embed=embed, view=self)

class LojaCarrosView(discord.ui.View):
    def __init__(self, user_id):
        super().__init__(timeout=300)
        self.user_id = user_id

    @discord.ui.button(label='üöó Populares', style=discord.ButtonStyle.secondary)
    async def populares_button(self, interaction: discord.Interaction, button: discord.ui.Button):
        if str(interaction.user.id) != self.user_id:
            await interaction.response.send_message("‚ùå Esta loja n√£o √© sua!", ephemeral=True)
            return
        await self.show_cars_category(interaction, "Carros Populares")

    @discord.ui.button(label='üèéÔ∏è Esportivos', style=discord.ButtonStyle.primary)
    async def esportivos_button(self, interaction: discord.Interaction, button: discord.ui.Button):
        if str(interaction.user.id) != self.user_id:
            await interaction.response.send_message("‚ùå Esta loja n√£o √© sua!", ephemeral=True)
            return
        await self.show_cars_category(interaction, "Carros Esportivos")

    @discord.ui.button(label='üíé Luxo', style=discord.ButtonStyle.success)
    async def luxo_button(self, interaction: discord.Interaction, button: discord.ui.Button):
        if str(interaction.user.id) != self.user_id:
            await interaction.response.send_message("‚ùå Esta loja n√£o √© sua!", ephemeral=True)
            return
        await self.show_cars_category(interaction, "Carros Luxo")

    @discord.ui.button(label='üî• Supercars', style=discord.ButtonStyle.danger)
    async def supercars_button(self, interaction: discord.Interaction, button: discord.ui.Button):
        if str(interaction.user.id) != self.user_id:
            await interaction.response.send_message("‚ùå Esta loja n√£o √© sua!", ephemeral=True)
            return
        await self.show_cars_category(interaction, "Supercars")

    @discord.ui.button(label='‚¨ÖÔ∏è Voltar', style=discord.ButtonStyle.blurple)
    async def voltar_button(self, interaction: discord.Interaction, button: discord.ui.Button):
        if str(interaction.user.id) != self.user_id:
            await interaction.response.send_message("‚ùå Esta loja n√£o √© sua!", ephemeral=True)
            return
        
        view = LojaMainView(self.user_id)
        embed = discord.Embed(
            title="üõí Instagram MXP - Lojinha",
            description="Bem-vindo √† lojinha! Escolha uma categoria:",
            color=0xE4405F
        )
        embed.add_field(
            name="üí∞ Dinheiro Dispon√≠vel",
            value=f"R$ {economy_data.get(self.user_id, {}).get('money', 0):,}".replace(",", "."),
            inline=False
        )
        embed.set_thumbnail(url="https://upload.wikimedia.org/wikipedia/commons/thumb/a/a5/Instagram_icon.png/1024px-Instagram_icon.png")
        await interaction.response.edit_message(embed=embed, view=view)

    async def show_cars_category(self, interaction, categoria):
        cars = {nome: info for nome, info in LOJA_ITEMS["carros"].items() if info["categoria"] == categoria}
        
        embed = discord.Embed(
            title=f"üöó {categoria}",
            description="Escolha um carro para comprar:",
            color=0x3498DB
        )
        
        view = CompraItemView(self.user_id, "carros", cars)
        
        for nome, info in list(cars.items())[:10]:  # Mostra at√© 10 carros
            embed.add_field(
                name=nome,
                value=f"üí∞ R$ {info['preco']:,}".replace(",", "."),
                inline=True
            )
        
        embed.set_footer(text="Selecione um carro no menu abaixo para comprar")
        await interaction.response.edit_message(embed=embed, view=view)

class LojaMansoesView(discord.ui.View):
    def __init__(self, user_id):
        super().__init__(timeout=300)
        self.user_id = user_id

    @discord.ui.button(label='üè† B√°sicas', style=discord.ButtonStyle.secondary)
    async def basicas_button(self, interaction: discord.Interaction, button: discord.ui.Button):
        if str(interaction.user.id) != self.user_id:
            await interaction.response.send_message("‚ùå Esta loja n√£o √© sua!", ephemeral=True)
            return
        await self.show_mansoes_category(interaction, "Resid√™ncias B√°sicas")

    @discord.ui.button(label='üè° M√©dias', style=discord.ButtonStyle.primary)
    async def medias_button(self, interaction: discord.Interaction, button: discord.ui.Button):
        if str(interaction.user.id) != self.user_id:
            await interaction.response.send_message("‚ùå Esta loja n√£o √© sua!", ephemeral=True)
            return
        await self.show_mansoes_category(interaction, "Resid√™ncias M√©dias")

    @discord.ui.button(label='üè∞ Mans√µes', style=discord.ButtonStyle.success)
    async def mansoes_button(self, interaction: discord.Interaction, button: discord.ui.Button):
        if str(interaction.user.id) != self.user_id:
            await interaction.response.send_message("‚ùå Esta loja n√£o √© sua!", ephemeral=True)
            return
        await self.show_mansoes_category(interaction, "Mans√µes")

    @discord.ui.button(label='üëë Ultra Premium', style=discord.ButtonStyle.danger)
    async def ultra_button(self, interaction: discord.Interaction, button: discord.ui.Button):
        if str(interaction.user.id) != self.user_id:
            await interaction.response.send_message("‚ùå Esta loja n√£o √© sua!", ephemeral=True)
            return
        await self.show_mansoes_category(interaction, "Ultra Premium")

    @discord.ui.button(label='üèõÔ∏è √önicas', style=discord.ButtonStyle.secondary, row=1)
    async def unicas_button(self, interaction: discord.Interaction, button: discord.ui.Button):
        if str(interaction.user.id) != self.user_id:
            await interaction.response.send_message("‚ùå Esta loja n√£o √© sua!", ephemeral=True)
            return
        await self.show_mansoes_category(interaction, "Propriedades √önicas")

    @discord.ui.button(label='‚¨ÖÔ∏è Voltar', style=discord.ButtonStyle.blurple, row=1)
    async def voltar_button(self, interaction: discord.Interaction, button: discord.ui.Button):
        if str(interaction.user.id) != self.user_id:
            await interaction.response.send_message("‚ùå Esta loja n√£o √© sua!", ephemeral=True)
            return
        
        view = LojaMainView(self.user_id)
        embed = discord.Embed(
            title="üõí Instagram MXP - Lojinha",
            description="Bem-vindo √† lojinha! Escolha uma categoria:",
            color=0xE4405F
        )
        embed.add_field(
            name="üí∞ Dinheiro Dispon√≠vel",
            value=f"R$ {economy_data.get(self.user_id, {}).get('money', 0):,}".replace(",", "."),
            inline=False
        )
        embed.set_thumbnail(url="https://upload.wikimedia.org/wikipedia/commons/thumb/a/a5/Instagram_icon.png/1024px-Instagram_icon.png")
        await interaction.response.edit_message(embed=embed, view=view)

    async def show_mansoes_category(self, interaction, categoria):
        mansoes = {nome: info for nome, info in LOJA_ITEMS["mansoes"].items() if info["categoria"] == categoria}
        
        embed = discord.Embed(
            title=f"üè∞ {categoria}",
            description="Escolha uma mans√£o para comprar:",
            color=0xE67E22
        )
        
        view = CompraItemView(self.user_id, "mansoes", mansoes)
        
        for nome, info in list(mansoes.items())[:10]:  # Mostra at√© 10 mans√µes
            embed.add_field(
                name=nome,
                value=f"üí∞ R$ {info['preco']:,}".replace(",", "."),
                inline=True
            )
        
        embed.set_footer(text="Selecione uma mans√£o no menu abaixo para comprar")
        await interaction.response.edit_message(embed=embed, view=view)

class LojaItensView(discord.ui.View):
    def __init__(self, user_id):
        super().__init__(timeout=300)
        self.user_id = user_id

    @discord.ui.button(label='‚òï Bebidas', style=discord.ButtonStyle.secondary)
    async def bebidas_button(self, interaction: discord.Interaction, button: discord.ui.Button):
        if str(interaction.user.id) != self.user_id:
            await interaction.response.send_message("‚ùå Esta loja n√£o √© sua!", ephemeral=True)
            return
        await self.show_itens_category(interaction, "Bebidas")

    @discord.ui.button(label='üì± Eletr√¥nicos', style=discord.ButtonStyle.primary)
    async def eletronicos_button(self, interaction: discord.Interaction, button: discord.ui.Button):
        if str(interaction.user.id) != self.user_id:
            await interaction.response.send_message("‚ùå Esta loja n√£o √© sua!", ephemeral=True)
            return
        await self.show_itens_category(interaction, "Eletr√¥nicos")

    @discord.ui.button(label='üëï Roupas', style=discord.ButtonStyle.success)
    async def roupas_button(self, interaction: discord.Interaction, button: discord.ui.Button):
        if str(interaction.user.id) != self.user_id:
            await interaction.response.send_message("‚ùå Esta loja n√£o √© sua!", ephemeral=True)
            return
        await self.show_itens_category(interaction, "Roupas")

    @discord.ui.button(label='üíé Luxo', style=discord.ButtonStyle.danger)
    async def luxo_button(self, interaction: discord.Interaction, button: discord.ui.Button):
        if str(interaction.user.id) != self.user_id:
            await interaction.response.send_message("‚ùå Esta loja n√£o √© sua!", ephemeral=True)
            return
        await self.show_itens_category(interaction, "Acess√≥rios de Luxo")

    @discord.ui.button(label='üéÆ Games', style=discord.ButtonStyle.primary, row=1)
    async def games_button(self, interaction: discord.Interaction, button: discord.ui.Button):
        if str(interaction.user.id) != self.user_id:
            await interaction.response.send_message("‚ùå Esta loja n√£o √© sua!", ephemeral=True)
            return
        await self.show_itens_category(interaction, "Games")

    @discord.ui.button(label='üíç Joias', style=discord.ButtonStyle.success, row=1)
    async def joias_button(self, interaction: discord.Interaction, button: discord.ui.Button):
        if str(interaction.user.id) != self.user_id:
            await interaction.response.send_message("‚ùå Esta loja n√£o √© sua!", ephemeral=True)
            return
        await self.show_itens_category(interaction, "Joias")

    @discord.ui.button(label='‚¨ÖÔ∏è Voltar', style=discord.ButtonStyle.blurple, row=1)
    async def voltar_button(self, interaction: discord.Interaction, button: discord.ui.Button):
        if str(interaction.user.id) != self.user_id:
            await interaction.response.send_message("‚ùå Esta loja n√£o √© sua!", ephemeral=True)
            return
        
        view = LojaMainView(self.user_id)
        embed = discord.Embed(
            title="üõí Instagram MXP - Lojinha",
            description="Bem-vindo √† lojinha! Escolha uma categoria:",
            color=0xE4405F
        )
        embed.add_field(
            name="üí∞ Dinheiro Dispon√≠vel",
            value=f"R$ {economy_data.get(self.user_id, {}).get('money', 0):,}".replace(",", "."),
            inline=False
        )
        embed.set_thumbnail(url="https://upload.wikimedia.org/wikipedia/commons/thumb/a/a5/Instagram_icon.png/1024px-Instagram_icon.png")
        await interaction.response.edit_message(embed=embed, view=view)

    async def show_itens_category(self, interaction, categoria):
        itens = {nome: info for nome, info in LOJA_ITEMS["itens_diarios"].items() if info["categoria"] == categoria}
        
        embed = discord.Embed(
            title=f"üõçÔ∏è {categoria}",
            description="Escolha um item para comprar:",
            color=0x27AE60
        )
        
        view = CompraItemView(self.user_id, "itens_diarios", itens)
        
        for nome, info in list(itens.items())[:10]:  # Mostra at√© 10 itens
            embed.add_field(
                name=nome,
                value=f"üí∞ R$ {info['preco']:,}".replace(",", "."),
                inline=True
            )
        
        embed.set_footer(text="Selecione um item no menu abaixo para comprar")
        await interaction.response.edit_message(embed=embed, view=view)

class CompraItemView(discord.ui.View):
    def __init__(self, user_id, tipo, items):
        super().__init__(timeout=300)
        self.user_id = user_id
        self.tipo = tipo
        self.items = items
        
        # Adiciona select menu com os itens
        self.add_item(ItemSelect(user_id, tipo, items))

    @discord.ui.button(label='‚¨ÖÔ∏è Voltar', style=discord.ButtonStyle.blurple, row=1)
    async def voltar_button(self, interaction: discord.Interaction, button: discord.ui.Button):
        if str(interaction.user.id) != self.user_id:
            await interaction.response.send_message("‚ùå Esta loja n√£o √© sua!", ephemeral=True)
            return
        
        # Volta para a categoria apropriada baseada no tipo
        if self.tipo == "carros":
            view = LojaCarrosView(self.user_id)
            embed = discord.Embed(
                title="üöó Carros Dispon√≠veis",
                description="Escolha a categoria de carros que deseja ver:",
                color=0x3498DB
            )
        elif self.tipo == "mansoes":
            view = LojaMansoesView(self.user_id)
            embed = discord.Embed(
                title="üè∞ Mans√µes Dispon√≠veis",
                description="Escolha a categoria de mans√µes que deseja ver:",
                color=0xE67E22
            )
        else:  # itens_diarios
            view = LojaItensView(self.user_id)
            embed = discord.Embed(
                title="üõçÔ∏è Itens do Dia a Dia",
                description="Escolha a categoria de itens que deseja ver:",
                color=0x27AE60
            )
        
        embed.set_thumbnail(url="https://cdn.discordapp.com/emojis/1387842927602172125.png")
        await interaction.response.edit_message(embed=embed, view=view)

class ItemSelect(discord.ui.Select):
    def __init__(self, user_id, tipo, items):
        self.user_id = user_id
        self.tipo = tipo
        self.items = items
        
        options = []
        for nome, info in list(items.items())[:25]:  # Discord limita a 25 op√ß√µes
            options.append(discord.SelectOption(
                label=nome,
                description=f"R$ {info['preco']:,} - {info['categoria']}".replace(",", "."),
                value=nome
            ))
        
        super().__init__(placeholder="Escolha um item para comprar...", options=options)

    async def callback(self, interaction: discord.Interaction):
        if str(interaction.user.id) != self.user_id:
            await interaction.response.send_message("‚ùå Esta loja n√£o √© sua!", ephemeral=True)
            return
        
        selected_item = self.values[0]
        item_info = self.items[selected_item]
        preco = item_info["preco"]
        
        # Verifica se tem dinheiro suficiente
        user_money = economy_data.get(self.user_id, {}).get("money", 0)
        
        if user_money < preco:
            embed = discord.Embed(
                title="‚ùå Dinheiro Insuficiente",
                description=f"Voc√™ n√£o tem dinheiro suficiente para comprar **{selected_item}**!",
                color=0xFF0000
            )
            embed.add_field(
                name="üí∞ Pre√ßo do Item",
                value=f"R$ {preco:,}".replace(",", "."),
                inline=True
            )
            embed.add_field(
                name="üíµ Seu Dinheiro",
                value=f"R$ {user_money:,}".replace(",", "."),
                inline=True
            )
            embed.add_field(
                name="üí° Como Ganhar Dinheiro",
                value="Use `m!publi` ap√≥s mencionar marcas famosas em posts longos!",
                inline=False
            )
            await interaction.response.edit_message(embed=embed, view=None)
            return
        
        # Realiza a compra
        economy_data[self.user_id]["money"] -= preco
        
        # Inicializa invent√°rio se n√£o existir
        if self.user_id not in inventory_data:
            inventory_data[self.user_id] = {"carros": [], "mansoes": [], "itens_diarios": []}
        
        # Adiciona item ao invent√°rio
        import datetime
        item_data = {
            "nome": selected_item,
            "preco": preco,
            "categoria": item_info["categoria"],
            "data_compra": datetime.datetime.now().isoformat()
        }
        inventory_data[self.user_id][self.tipo].append(item_data)
        
        # Salva os dados
        save_economy_data()
        save_inventory_data()
        
        # Embed de sucesso
        embed = discord.Embed(
            title="‚úÖ Compra Realizada!",
            description=f"Voc√™ comprou **{selected_item}** com sucesso!",
            color=0x00FF00
        )
        
        embed.add_field(
            name="üõí Item Comprado",
            value=f"**{selected_item}**\n{item_info['categoria']}",
            inline=True
        )
        
        embed.add_field(
            name="üí∞ Valor Pago",
            value=f"R$ {preco:,}".replace(",", "."),
            inline=True
        )
        
        embed.add_field(
            name="üíµ Dinheiro Restante",
            value=f"R$ {economy_data[self.user_id]['money']:,}".replace(",", "."),
            inline=True
        )
        
        # Tipo de item espec√≠fico
        if self.tipo == "carros":
            embed.set_thumbnail(url="https://cdn.discordapp.com/emojis/1387842927602172125.png")
            embed.add_field(
                name="üöó Novo Carro!",
                value="Seu novo carro foi adicionado √† sua garagem!",
                inline=False
            )
        elif self.tipo == "mansoes":
            embed.set_thumbnail(url="https://cdn.discordapp.com/emojis/1387842927602172125.png")
            embed.add_field(
                name="üè∞ Nova Propriedade!",
                value="Sua nova mans√£o foi adicionada ao seu portf√≥lio imobili√°rio!",
                inline=False
            )
        else:
            embed.set_thumbnail(url="https://cdn.discordapp.com/emojis/1381003788135174316.png")
            embed.add_field(
                name="üõçÔ∏è Novo Item!",
                value="Seu item foi adicionado ao invent√°rio!",
                inline=False
            )
        
        # Bot√£o para voltar √† loja
        view = discord.ui.View()
        voltar_button = discord.ui.Button(label="üõí Voltar √† Loja", style=discord.ButtonStyle.primary)
        
        async def voltar_callback(button_interaction):
            if str(button_interaction.user.id) != self.user_id:
                await button_interaction.response.send_message("‚ùå Esta loja n√£o √© sua!", ephemeral=True)
                return
            
            main_view = LojaMainView(self.user_id)
            main_embed = discord.Embed(
                title="üõí Instagram MXP - Lojinha",
                description="Bem-vindo √† lojinha! Escolha uma categoria:",
                color=0xE4405F
            )
            main_embed.add_field(
                name="üí∞ Dinheiro Dispon√≠vel",
                value=f"R$ {economy_data.get(self.user_id, {}).get('money', 0):,}".replace(",", "."),
                inline=False
            )
            main_embed.set_thumbnail(url="https://upload.wikimedia.org/wikipedia/commons/thumb/a/a5/Instagram_icon.png/1024px-Instagram_icon.png")
            await button_interaction.response.edit_message(embed=main_embed, view=main_view)
        
        voltar_button.callback = voltar_callback
        view.add_item(voltar_button)
        
        embed.set_footer(text=f"Compra realizada por {interaction.user.display_name}")
        await interaction.response.edit_message(embed=embed, view=view)
        
        print(f"üí∞ Compra realizada: {interaction.user.display_name} comprou {selected_item} por R${preco:,}")

class HelpView(discord.ui.View):
    def __init__(self, ctx):
        super().__init__(timeout=300)
        self.ctx = ctx

    @discord.ui.button(label='üéØ Comandos B√°sicos', style=discord.ButtonStyle.primary)
    async def comandos_basicos(self, interaction: discord.Interaction, button: discord.ui.Button):
        embed = discord.Embed(
            title="üéØ Comandos B√°sicos - Instagram MXP",
            description="Comandos essenciais para come√ßar",
            color=0x00FF00
        )
        embed.add_field(
            name="`m!seguidores`",
            value="üìä Registra seu perfil e ganha seguidores aleat√≥rios",
            inline=False
        )
        embed.add_field(
            name="`m!perfil [@usu√°rio]`",
            value="üë§ Mostra perfil do Instagram (seu ou de outro usu√°rio)",
            inline=False
        )
        embed.add_field(
            name="`m!atualizar`",
            value="üìù Atualiza nome e profiss√£o via formul√°rio modal",
            inline=False
        )
        embed.add_field(
            name="`m!publi`",
            value="üíº Ganha dinheiro fazendo publicidade (mencione marcas!)",
            inline=False
        )
        embed.add_field(
            name="`m!economia [@usu√°rio]`",
            value="üí∞ V√™ saldo de dinheiro e pontos de fama",
            inline=False
        )
        embed.add_field(
            name="`m!lojinha`",
            value="üõí Loja com carros, mans√µes e itens do dia a dia",
            inline=False
        )
        embed.add_field(
            name="`m!teste`",
            value="üîß Testa se o bot est√° funcionando",
            inline=False
        )
        embed.set_thumbnail(url="https://upload.wikimedia.org/wikipedia/commons/thumb/a/a5/Instagram_icon.png/1024px-Instagram_icon.png")
        embed.set_footer(text=f"Ajuda solicitada por {self.ctx.author.display_name}")
        await interaction.response.send_message(embed=embed, ephemeral=True)

    @discord.ui.button(label='üë• Comandos Sociais', style=discord.ButtonStyle.secondary)
    async def comandos_sociais(self, interaction: discord.Interaction, button: discord.ui.Button):
        embed = discord.Embed(
            title="üë• Comandos Sociais - Instagram MXP",
            description="Interaja com outros usu√°rios",
            color=0x1DA1F2
        )
        embed.add_field(
            name="`m!seguir @usu√°rio`",
            value="‚ûï Segue um usu√°rio (pode virar amigo m√∫tuo!)",
            inline=False
        )
        embed.add_field(
            name="`m!desseguir @usu√°rio`",
            value="‚ûñ Para de seguir um usu√°rio",
            inline=False
        )
        embed.add_field(
            name="`m!seguidores_lista [@usu√°rio]`",
            value="üìã Lista completa dos seguidores",
            inline=False
        )
        embed.add_field(
            name="`m!seguindo [@usu√°rio]`",
            value="üìã Lista quem est√° seguindo",
            inline=False
        )
        embed.set_thumbnail(url="https://cdn.discordapp.com/emojis/1387605173886783620.png")
        embed.set_footer(text=f"Ajuda solicitada por {self.ctx.author.display_name}")
        await interaction.response.send_message(embed=embed, ephemeral=True)

    @discord.ui.button(label='üèÜ Rankings & Stats', style=discord.ButtonStyle.success)
    async def comandos_stats(self, interaction: discord.Interaction, button: discord.ui.Button):
        embed = discord.Embed(
            title="üèÜ Rankings & Estat√≠sticas - Instagram MXP",
            description="Veja os melhores e estat√≠sticas globais",
            color=0xFFD700
        )
        embed.add_field(
            name="`m!curtidas`",
            value="üèÜ Top 10 usu√°rios com mais curtidas",
            inline=False
        )
        embed.add_field(
            name="`m!stats`",
            value="üìä Estat√≠sticas globais do bot",
            inline=False
        )
        embed.add_field(
            name="`m!reset`",
            value="üóëÔ∏è Reseta todos os seus dados (irrevers√≠vel)",
            inline=False
        )
        embed.set_thumbnail(url="https://cdn.discordapp.com/emojis/1376731577106567319.png")
        embed.set_footer(text=f"Ajuda solicitada por {self.ctx.author.display_name}")
        await interaction.response.send_message(embed=embed, ephemeral=True)

    @discord.ui.button(label='‚ÑπÔ∏è Informa√ß√µes', style=discord.ButtonStyle.blurple)
    async def comandos_info(self, interaction: discord.Interaction, button: discord.ui.Button):
        embed = discord.Embed(
            title="‚ÑπÔ∏è Informa√ß√µes & Outros - Instagram MXP",
            description="Informa√ß√µes sobre o bot e como funciona",
            color=0x9932CC
        )
        embed.add_field(
            name="`m!sobre`",
            value="üì± Informa√ß√µes detalhadas sobre o bot",
            inline=False
        )
        embed.add_field(
            name="`m!ajuda`",
            value="üìö Mostra este menu de ajuda",
            inline=False
        )
        embed.add_field(
            name="üí° Como Funciona:",
            value="‚Ä¢ Reaja com <:mxplike1:1381003788135174316> nas mensagens para dar curtidas\n‚Ä¢ Cada 10 curtidas = 1 level\n‚Ä¢ Use bot√µes no perfil para personalizar imagens\n‚Ä¢ Seguidores s√£o ganhos aleatoriamente no primeiro uso\n‚Ä¢ 500k+ seguidores = verifica√ß√£o autom√°tica",
            inline=False
        )
        embed.set_thumbnail(url="https://upload.wikimedia.org/wikipedia/commons/thumb/c/ce/Circle-icons-info.svg/1024px-Circle-icons-info.svg.png")
        embed.set_footer(text=f"Ajuda solicitada por {self.ctx.author.display_name}")
        await interaction.response.send_message(embed=embed, ephemeral=True)

# Comando de ajuda
@bot.command(name='ajuda', aliases=['ajudainsta'])
async def ajuda(ctx):
    embed = discord.Embed(
        title="üìö Central de Ajuda - Instagram MXP",
        description="Selecione uma categoria para ver os comandos dispon√≠veis:",
        color=0xE4405F
    )

    embed.add_field(
        name="üéØ Comandos B√°sicos",
        value="Registro, perfil e personaliza√ß√£o",
        inline=True
    )

    embed.add_field(
        name="üë• Comandos Sociais",
        value="Seguir, seguidores e relacionamentos",
        inline=True
    )

    embed.add_field(
        name="üèÜ Rankings & Stats",
        value="Rankings e estat√≠sticas globais",
        inline=True
    )

    embed.add_field(
        name="‚ÑπÔ∏è Informa√ß√µes",
        value="Sobre o bot e como funciona",
        inline=True
    )

    embed.add_field(
        name="üí° Dica R√°pida:",
        value="Clique nos bot√µes abaixo para ver os comandos de cada categoria!",
        inline=False
    )

    embed.set_thumbnail(url="https://upload.wikimedia.org/wikipedia/commons/thumb/a/a5/Instagram_icon.png/1024px-Instagram_icon.png")
    embed.set_footer(text=f"Solicitado por {ctx.author.display_name} ‚Ä¢ Use os bot√µes para navegar")

    view = HelpView(ctx)
    await ctx.reply(embed=embed, view=view)

# Comando de estat√≠sticas globais
@bot.command(name='stats', aliases=['status'])
async def stats(ctx):
    total_users = len(user_data)
    total_likes = sum(user.get('total_likes', 0) for user in user_data.values())
    total_followers = sum(user.get('followers', 0) for user in user_data.values())
    total_relationships = len(follow_data)

    # Calcula relacionamentos ativos
    active_following = sum(len(data.get('following', [])) for data in follow_data.values())

    embed = discord.Embed(
        title="üìä Estat√≠sticas Globais do Instagram MXP",
        description="Dados gerais da plataforma",
        color=0x9932CC
    )

    embed.add_field(
        name="üë• Usu√°rios",
        value=f"**{total_users:,}** usu√°rios registrados".replace(",", "."),
        inline=True
    )

    embed.add_field(
        name="üíñ Curtidas Totais",
        value=f"**{total_likes:,}** curtidas dadas".replace(",", "."),
        inline=True
    )

    embed.add_field(
        name="üìà Seguidores Totais",
        value=f"**{total_followers:,}** seguidores".replace(",", "."),
        inline=True
    )

    embed.add_field(
        name="ü§ù Relacionamentos",
        value=f"**{active_following:,}** conex√µes ativas".replace(",", "."),
        inline=True
    )

    # Top usu√°rio
    if user_data:
        top_user_id = max(user_data, key=lambda x: user_data[x].get('total_likes', 0))
        top_user = bot.get_user(int(top_user_id))
        top_likes = user_data[top_user_id].get('total_likes', 0)

        if top_user:
            embed.add_field(
                name="üëë Usu√°rio com Mais Curtidas",
                value=f"**{top_user.display_name}** - {top_likes:,} curtidas".replace(",", "."),
                inline=False
            )

    embed.set_thumbnail(url=ctx.guild.icon.url if ctx.guild.icon else None)
    embed.set_footer(text=f"Dev: YevgennyMXP ‚Ä¢ Consultado por {ctx.author.display_name}")

    await ctx.reply(embed=embed)

# Comando para resetar dados do usu√°rio
@bot.command(name='reset')
async def reset_user(ctx):
    user_id = str(ctx.author.id)

    # Verifica se o usu√°rio j√° usou o reset
    if user_id in reset_data:
        embed = discord.Embed(
            title="‚ùå Reset j√° utilizado!",
            description="Voc√™ j√° usou o comando `m!reset` anteriormente.",
            color=0xFF0000
        )
        embed.add_field(
            name="üö´ Limita√ß√£o:",
            value="O comando `m!reset` s√≥ pode ser usado **uma vez por pessoa** para evitar abusos.",
            inline=False
        )
        embed.add_field(
            name="üí° Alternativa:",
            value="Se voc√™ quiser alterar apenas algumas informa√ß√µes, use:\n‚Ä¢ `m!atualizar` - para nome e profiss√£o\n‚Ä¢ Bot√µes no `m!perfil` - para imagens",
            inline=False
        )
        embed.set_footer(text="Dev: YevgennyMXP ‚Ä¢ Esta limita√ß√£o √© permanente")
        await ctx.reply(embed=embed)
        return

    if user_id not in user_data:
        embed = discord.Embed(
            title="‚ùå Nada para resetar",
            description="Voc√™ n√£o possui dados registrados!",
            color=0xFF0000
        )
        await ctx.reply(embed=embed)
        return

    # Confirma a a√ß√£o
    embed = discord.Embed(
        title="‚ö†Ô∏è Confirma√ß√£o de Reset",
        description="Tem certeza que deseja **DELETAR TODOS** os seus dados?",
        color=0xFF8C00
    )
    embed.add_field(
        name="üóëÔ∏è Dados que ser√£o removidos:",
        value="‚Ä¢ Nome de usu√°rio e profiss√£o\n‚Ä¢ Total de curtidas e level\n‚Ä¢ Seguidores do Instagram\n‚Ä¢ Imagens personalizadas\n‚Ä¢ Todos os relacionamentos (seguir/seguidores)",
        inline=False
    )
    embed.add_field(
        name="‚ùó ATEN√á√ÉO:",
        value="**Esta a√ß√£o √© IRREVERS√çVEL!**\nVoc√™ precisar√° usar `m!seguidores` novamente para se registrar.\n\n**‚ö†Ô∏è IMPORTANTE:** Voc√™ s√≥ pode usar este comando **UMA VEZ**!",
        inline=False
    )

    # Bot√µes de confirma√ß√£o
    view = discord.ui.View(timeout=60)

    # Bot√£o de confirmar
    confirm_button = discord.ui.Button(
        label="‚úÖ Sim, deletar tudo",
        style=discord.ButtonStyle.danger,
        emoji="üóëÔ∏è"
    )

    async def confirm_callback(interaction):
        if interaction.user.id != ctx.author.id:
            await interaction.response.send_message("‚ùå Apenas quem solicitou pode confirmar!", ephemeral=True)
            return

        # Remove dados do usu√°rio
        if user_id in user_data:
            del user_data[user_id]

        # Remove relacionamentos
        if user_id in follow_data:
            # Remove das listas de following de outros usu√°rios
            for other_user_id in follow_data[user_id].get("following", []):
                if other_user_id in follow_data and user_id in follow_data[other_user_id].get("followers", []):
                    follow_data[other_user_id]["followers"].remove(user_id)

            # Remove das listas de followers de outros usu√°rios
            for other_user_id in follow_data[user_id].get("followers", []):
                if other_user_id in follow_data and user_id in follow_data[other_user_id].get("following", []):
                    follow_data[other_user_id]["following"].remove(user_id)

            del follow_data[user_id]

        # Marca que o usu√°rio usou o reset
        reset_data[user_id] = True

        save_user_data()
        save_follow_data()
        save_reset_data()

        success_embed = discord.Embed(
            title="‚úÖ Dados Resetados!",
            description="Todos os seus dados foram removidos com sucesso.",
            color=0x00FF00
        )
        success_embed.add_field(
            name="üîÑ Pr√≥ximos Passos:",
            value="Use `m!seguidores` para se registrar novamente e come√ßar do zero!",
            inline=False
        )
        success_embed.add_field(
            name="‚ö†Ô∏è Importante:",
            value="Voc√™ **n√£o poder√° usar** o comando `m!reset` novamente. Este era seu √∫nico uso!",
            inline=False
        )
        success_embed.set_footer(text="Reset realizado com sucesso ‚Ä¢ Uma vez por usu√°rio")

        await interaction.response.edit_message(embed=success_embed, view=None)

    # Bot√£o de cancelar
    cancel_button = discord.ui.Button(
        label="‚ùå Cancelar",
        style=discord.ButtonStyle.secondary,
        emoji="üö´"
    )

    async def cancel_callback(interaction):
        if interaction.user.id != ctx.author.id:
            await interaction.response.send_message("‚ùå Apenas quem solicitou pode cancelar!", ephemeral=True)
            return

        cancel_embed = discord.Embed(
            title="‚ùå Reset Cancelado",
            description="Seus dados est√£o seguros! Nenhuma altera√ß√£o foi feita.",
            color=0x00FF00
        )
        await interaction.response.edit_message(embed=cancel_embed, view=None)

    confirm_button.callback = confirm_callback
    cancel_button.callback = cancel_callback

    view.add_item(confirm_button)
    view.add_item(cancel_button)

    await ctx.reply(embed=embed, view=view)

# Comando sobre o bot
@bot.command(name='sobre', aliases=['info'])
async def sobre(ctx):
    embed = discord.Embed(
        title="üì± Instagram MXP Bot",
        description="Simulador de Instagram para Discord",
        color=0xE4405F
    )

    embed.add_field(
        name="üéØ Funcionalidades Principais",
        value="‚Ä¢ Sistema de perfis personalizados\n‚Ä¢ Curtidas autom√°ticas nas mensagens\n‚Ä¢ Relacionamentos sociais (seguir/seguidores)\n‚Ä¢ Rankings e estat√≠sticas\n‚Ä¢ Modals para atualiza√ß√£o de dados",
        inline=False
    )

    embed.add_field(
        name="üîß Recursos T√©cnicos",
        value="‚Ä¢ Armazenamento em JSON\n‚Ä¢ Sistema de levels baseado em curtidas\n‚Ä¢ Verifica√ß√£o autom√°tica (500k+ seguidores)\n‚Ä¢ Bot√µes e modals interativos\n‚Ä¢ Sistema de relacionamentos em tempo real",
        inline=False
    )

    embed.add_field(
        name="üìä Como Usar",
        value="1. Use `m!seguidores` para se registrar\n2. Customize seu perfil com `m!atualizar`\n3. Interaja reagindo √†s mensagens\n4. Siga outros usu√°rios com `m!seguir`\n5. Veja seu progresso com `m!perfil`",
        inline=False
    )

    embed.add_field(
        name="üíª Desenvolvido em",
        value="Python + Node.JS + Discord.py",
        inline=True
    )

    embed.add_field(
        name="üèÜ Vers√£o",
        value="2.0 - Sistema Social",
        inline=True
    )

    embed.set_thumbnail(url="https://upload.wikimedia.org/wikipedia/commons/thumb/a/a5/Instagram_icon.png/1024px-Instagram_icon.png")
    embed.set_footer(text=f"Dev: YevgennyMXP ‚Ä¢ Consultado por {ctx.author.display_name}")

    await ctx.reply(embed=embed)

# Comando para verificar engajamento
@bot.command(name='engajamento')
async def engajamento(ctx, member: discord.Member = None):
    if member is None:
        member = ctx.author

    user_id = str(member.id)

    if user_id not in user_data:
        embed = discord.Embed(
            title="‚ùå Usu√°rio n√£o registrado",
            description=f"{member.display_name} precisa se registrar primeiro!",
            color=0xFF0000
        )
        await ctx.reply(embed=embed)
        return

    likes = user_data[user_id].get('total_likes', 0)
    followers = user_data[user_id].get('followers', 0)

    if followers == 0:
        taxa_engajamento = 0
    else:
        taxa_engajamento = (likes / followers) * 100

    # Classifica o engajamento
    if taxa_engajamento >= 10:
        classificacao = "üî• EXTRAORDIN√ÅRIO"
        cor = 0xFF0000
    elif taxa_engajamento >= 5:
        classificacao = "‚≠ê EXCELENTE"
        cor = 0xFF6B35
    elif taxa_engajamento >= 2:
        classificacao = "üìà BOM"
        cor = 0xFFD23F
    elif taxa_engajamento >= 1:
        classificacao = "üìä M√âDIO"
        cor = 0x06FFA5
    else:
        classificacao = "üìâ BAIXO"
        cor = 0x95E1D3

    embed = discord.Embed(
        title="üìä An√°lise de Engajamento",
        description=f"Taxa de engajamento de **{member.display_name}**",
        color=cor
    )

    embed.add_field(
        name="üìà Taxa de Engajamento",
        value=f"**{taxa_engajamento:.2f}%**",
        inline=True
    )

    embed.add_field(
        name="üèÜ Classifica√ß√£o",
        value=classificacao,
        inline=True
    )

    embed.add_field(
        name="üìä Dados Base",
        value=f"üíñ {likes:,} curtidas\nüë• {followers:,} seguidores".replace(",", "."),
        inline=False
    )

    # Dicas para melhorar
    if taxa_engajamento < 2:
        embed.add_field(
            name="üí° Dica para Melhorar",
            value="Interaja mais no servidor! Envie mensagens nos canais permitidos para ganhar mais curtidas.",
            inline=False
        )

    embed.set_thumbnail(url=member.display_avatar.url)
    embed.set_footer(text=f"Dev: YevgennyMXP ‚Ä¢ Consultado por {ctx.author.display_name}")

    await ctx.reply(embed=embed)

# Comando para sugerir perfis para seguir
@bot.command(name='sugestoes')
async def sugestoes(ctx):
    user_id = str(ctx.author.id)

    if user_id not in user_data:
        embed = discord.Embed(
            title="‚ùå Registro necess√°rio",
            description="Voc√™ precisa se registrar primeiro!",
            color=0xFF0000
        )
        await ctx.reply(embed=embed)
        return

    # Pega usu√°rios que o autor n√£o segue
    following = follow_data.get(user_id, {}).get("following", [])
    suggestions = []

    for other_user_id, data in user_data.items():
        if other_user_id != user_id and other_user_id not in following:
            try:
                user = bot.get_user(int(other_user_id))
                if user:
                    followers_count = data.get('followers', 0)
                    likes_count = data.get('total_likes', 0)
                    suggestions.append((other_user_id, user, followers_count, likes_count))
            except:
                continue

    if not suggestions:
        embed = discord.Embed(
            title="üòÖ Nenhuma Sugest√£o",
            description="Voc√™ j√° segue todos os usu√°rios registrados!",
            color=0x9932CC
        )
        await ctx.reply(embed=embed)
        return

    # Ordena por seguidores e pega os top 5
    suggestions.sort(key=lambda x: x[2], reverse=True)
    top_suggestions = suggestions[:5]

    embed = discord.Embed(
        title="üë• Sugest√µes para Seguir",
        description="Perfis populares que voc√™ ainda n√£o segue:",
        color=0x1DA1F2
    )

    for i, (user_id_sug, user, followers, likes) in enumerate(top_suggestions):
        username = user_data[user_id_sug].get('username', user.display_name)

        # Adiciona verifica√ß√£o baseada nos n√≠veis de seguidores
        if user_id_sug == "983196900910039090":  # Owner ID
            username += " <:extremomxp:1387842927602172125>"
        elif followers >= 1000000:
            username += " <:abudabimxp:1387843390506405922>"
        elif followers >= 500000:
            username += " <:verificadomxp:1387605173886783620>"
        else:
            username += " <:verificiadinmxp:1387842858912055428>"

        # Adiciona emoji baseado nos seguidores
        if followers >= 5000000:
            emoji = "üíé"
            status = " (Mega Influencer)"
        elif followers >= 1000000:
            emoji = "üî•"
            status = " (Influencer)"
        elif followers >= 500000:
            emoji = "‚≠ê"
            status = " (Verificado)"
        else:
            emoji = "üë§"
            status = ""

        embed.add_field(
            name=f"{emoji} @{username}{status}",
            value=f"üë• {followers:,} seguidores\nüíñ {likes:,} curtidas".replace(",", "."),
            inline=True
        )

    embed.add_field(
        name="üí° Como Seguir",
        value="Use `m!seguir @usuario` para seguir algu√©m da lista!",
        inline=False
    )

    embed.set_footer(text=f"Dev: YevgennyMXP ‚Ä¢ Sugest√µes para {ctx.author.display_name}")
    await ctx.reply(embed=embed)

# Comando para publicidade (m!publi)
@bot.command(name='publi')
async def publicidade(ctx):
    user_id = str(ctx.author.id)

    # Verifica se o usu√°rio est√° registrado
    if user_id not in user_data:
        embed = discord.Embed(
            title="‚ùå Registro necess√°rio",
            description="Voc√™ precisa se registrar primeiro!",
            color=0xFF0000
        )
        embed.add_field(
            name="üìù Como se registrar:",
            value="Use o comando `m!seguidores` para criar seu perfil",
            inline=False
        )
        await ctx.reply(embed=embed)
        return

    # Verifica se o usu√°rio tem posts com marcas detectadas
    if user_id not in brand_posts_data or not brand_posts_data[user_id]:
        embed = discord.Embed(
            title="üí° Sistema de Publicidade Autom√°tica",
            description="As recompensas agora s√£o **autom√°ticas**! N√£o √© mais necess√°rio usar comandos.",
            color=0x00D2FF
        )
        embed.add_field(
            name="ü§ñ Como Funciona Agora:",
            value="1. Poste uma mensagem (40+ caracteres) mencionando uma marca famosa nos canais do Instagram\n2. O bot **detecta automaticamente** e responde com suas recompensas\n3. N√£o √© mais necess√°rio usar `m!publi`!",
            inline=False
        )
        embed.add_field(
            name="üè∑Ô∏è Exemplos de marcas:",
            value="Nike, Apple, Coca-Cola, Samsung, Instagram, etc.",
            inline=False
        )
        embed.add_field(
            name="‚ú® Vantagens:",
            value="‚Ä¢ Recompensas instant√¢neas\n‚Ä¢ Sem necessidade de comandos\n‚Ä¢ Detec√ß√£o autom√°tica de marcas\n‚Ä¢ Resposta imediata ao seu post",
            inline=False
        )
        await ctx.reply(embed=embed)
        return

    # Conta posts j√° recompensados automaticamente
    rewarded_posts = sum(1 for post_data in brand_posts_data[user_id].values() if post_data.get("rewarded", False))
    total_money_earned = sum(post_data.get("money_gained", 0) for post_data in brand_posts_data[user_id].values() if post_data.get("rewarded", False))
    total_fame_earned = sum(post_data.get("fame_gained", 0) for post_data in brand_posts_data[user_id].values() if post_data.get("rewarded", False))

    embed = discord.Embed(
        title="üìä Relat√≥rio de Publicidade Autom√°tica",
        description="Suas recompensas autom√°ticas de publicidade:",
        color=0x00FF00
    )

    embed.add_field(
        name="üì± Posts Recompensados",
        value=f"**{rewarded_posts}** posts com marcas detectadas",
        inline=True
    )

    embed.add_field(
        name="üí∞ Total Ganho",
        value=f"üíµ R$ {total_money_earned:,}\n‚≠ê {total_fame_earned:,} pontos de fama".replace(",", "."),
        inline=True
    )

    embed.add_field(
        name="üí° Sistema Autom√°tico",
        value="‚úÖ **Ativo** - Suas publicidades s√£o detectadas automaticamente!",
        inline=False
    )

    # Mostra as √∫ltimas 3 recompensas
    recent_posts = []
    for message_id, post_data in brand_posts_data[user_id].items():
        if post_data.get("rewarded", False):
            recent_posts.append((message_id, post_data))
    
    if recent_posts:
        recent_posts.sort(key=lambda x: x[1]["timestamp"], reverse=True)
        recent_text = ""
        for i, (msg_id, post_data) in enumerate(recent_posts[:3]):
            brands = ", ".join(post_data["brands"][:2])  # Mostra at√© 2 marcas
            money_gained = post_data.get("money_gained", 0)
            recent_text += f"**{i+1}.** {brands} - R$ {money_gained:,}\n".replace(",", ".")
        
        embed.add_field(
            name="üïê √öltimas Recompensas",
            value=recent_text,
            inline=False
        )

    embed.add_field(
        name="üéØ Pr√≥ximos Passos:",
        value="Continue postando sobre marcas (40+ caracteres) para ganhar mais recompensas autom√°ticas!",
        inline=False
    )

    embed.set_thumbnail(url="https://cdn.discordapp.com/emojis/1381003788135174316.png")
    embed.set_footer(text=f"Relat√≥rio gerado para {ctx.author.display_name}")

    await ctx.reply(embed=embed)

    print(f"üìä Relat√≥rio de publicidade mostrado para {ctx.author.display_name}: {rewarded_posts} posts, R${total_money_earned} total")

# Comando para verificar status dos dados
@bot.command(name='debug_dados')
async def debug_dados(ctx):
    """Comando para debug detalhado dos dados"""
    # S√≥ o dono do bot pode usar
    if str(ctx.author.id) != "983196900910039090":
        await ctx.reply("‚ùå Apenas o dono do bot pode usar este comando!")
        return
    
    print(f"üîç DEBUG DADOS: Comando executado por {ctx.author.display_name}")
    
    # Debug dos dados em mem√≥ria
    print(f"üîç DEBUG: user_data em mem√≥ria: {len(user_data)} usu√°rios")
    for user_id, data in user_data.items():
        username = data.get('username')
        followers = data.get('followers', 0)
        print(f"üìù Mem√≥ria: {user_id} | username: '{username}' | followers: {followers}")
    
    # Debug do MongoDB
    if db is not None:
        collection = db.user_data
        mongo_count = collection.count_documents({})
        print(f"üîç DEBUG: MongoDB user_data: {mongo_count} documentos")
        
        docs = collection.find({}).limit(10)
        for doc in docs:
            user_id = doc['_id']
            username = doc.get('username')
            followers = doc.get('followers', 0)
            print(f"üìä MongoDB: {user_id} | username: '{username}' | followers: {followers}")
    
    # Testa o ranking
    print(f"üîç DEBUG: Testando get_ranking_data('seguidores')...")
    ranking_result = get_ranking_data('seguidores')
    print(f"üîç DEBUG: Resultado do ranking: {len(ranking_result)} usu√°rios")
    
    embed = discord.Embed(
        title="üîç Debug de Dados Completo",
        description="Verifica√ß√£o detalhada dos dados (check console)",
        color=0x00FF00
    )
    embed.add_field(
        name="üìä Dados em Mem√≥ria",
        value=f"**{len(user_data)}** usu√°rios carregados",
        inline=True
    )
    
    if db is not None:
        mongo_count = db.user_data.count_documents({})
        embed.add_field(
            name="üçÉ MongoDB",
            value=f"**{mongo_count}** documentos salvos",
            inline=True
        )
    
    embed.add_field(
        name="üèÜ Ranking",
        value=f"**{len(ranking_result)}** usu√°rios v√°lidos para ranking",
        inline=True
    )
    
    embed.add_field(
        name="üìã Detalhes no Console",
        value="Verifique o console para logs detalhados de cada usu√°rio",
        inline=False
    )
    
    await ctx.reply(embed=embed)

@bot.command(name='recarregar_dados')
async def recarregar_dados(ctx):
    # S√≥ o dono do bot pode usar
    if str(ctx.author.id) != "983196900910039090":
        await ctx.reply("‚ùå Apenas o dono do bot pode usar este comando!")
        return
    
    embed = discord.Embed(
        title="üîÑ Recarregando Dados...",
        description="For√ßando recarregamento dos dados do MongoDB",
        color=0xFFD700
    )
    
    msg = await ctx.reply(embed=embed)
    
    try:
        # Recarrega todos os dados
        load_user_data()
        load_follow_data()
        load_economy_data()
        load_brand_posts_data()
        load_inventory_data()
        load_reset_data()
        
        success_embed = discord.Embed(
            title="‚úÖ Dados Recarregados!",
            description="Todos os dados foram recarregados do MongoDB",
            color=0x00FF00
        )
        
        success_embed.add_field(
            name="üìä Dados Carregados",
            value=f"üë• {len(user_data)} usu√°rios\nüí∞ {len(economy_data)} economias\nü§ù {len(follow_data)} relacionamentos\nüì¶ {len(inventory_data)} invent√°rios\nüìù {len(brand_posts_data)} posts\nüîÑ {len(reset_data)} resets",
            inline=False
        )
        
        # Mostra alguns usu√°rios carregados
        if user_data:
            usuarios_info = ""
            for i, (user_id, data) in enumerate(list(user_data.items())[:5]):
                username = data.get('username')
                followers = data.get('followers', 0)
                usuarios_info += f"{i+1}. @{username} ({user_id[:8]}...) - {followers:,} seg\n".replace(",", ".")
            
            success_embed.add_field(
                name="üë• Usu√°rios Carregados (amostra)",
                value=usuarios_info or "Nenhum usu√°rio encontrado",
                inline=False
            )
        
        await msg.edit(embed=success_embed)
        
    except Exception as e:
        error_embed = discord.Embed(
            title="‚ùå Erro ao Recarregar",
            description=f"Erro: {str(e)}",
            color=0xFF0000
        )
        await msg.edit(embed=error_embed)

@bot.command(name='corrigir_dados')
async def corrigir_dados(ctx):
    """Corrige documentos no MongoDB que n√£o t√™m discord_id"""
    # S√≥ o dono do bot pode usar
    if str(ctx.author.id) != "983196900910039090":
        await ctx.reply("‚ùå Apenas o dono do bot pode usar este comando!")
        return
    
    if db is None:
        await ctx.reply("‚ùå MongoDB n√£o conectado!")
        return
    
    embed = discord.Embed(
        title="üîß Corrigindo Dados MongoDB",
        description="Procurando documentos sem discord_id...",
        color=0xFFD700
    )
    msg = await ctx.reply(embed=embed)
    
    try:
        collection = db.user_data
        documents_without_discord_id = collection.find({"discord_id": {"$exists": False}})
        
        corrected = 0
        failed = 0
        
        for doc in documents_without_discord_id:
            username = doc['_id']
            print(f"üîß Tentando corrigir documento: @{username}")
            
            # Se o username parece ser um ID do Discord
            if username.isdigit() and len(username) >= 17:
                # Atualiza o documento adicionando discord_id
                collection.update_one(
                    {"_id": username},
                    {"$set": {"discord_id": username}}
                )
                corrected += 1
                print(f"‚úÖ Corrigido: {username} agora tem discord_id")
            else:
                # Tenta encontrar o usu√°rio no servidor
                found = False
                for member in bot.get_all_members():
                    if member.display_name.lower() == username.lower() or member.name.lower() == username.lower():
                        # Encontrou! Adiciona o discord_id
                        collection.update_one(
                            {"_id": username},
                            {"$set": {"discord_id": str(member.id)}}
                        )
                        corrected += 1
                        found = True
                        print(f"‚úÖ Corrigido: @{username} -> discord_id: {member.id}")
                        break
                
                if not found:
                    failed += 1
                    print(f"‚ùå N√£o encontrado: @{username}")
        
        # Recarrega os dados
        load_user_data()
        
        success_embed = discord.Embed(
            title="‚úÖ Corre√ß√£o Conclu√≠da!",
            description="Dados do MongoDB foram corrigidos",
            color=0x00FF00
        )
        
        success_embed.add_field(
            name="üìä Resultado",
            value=f"‚úÖ **{corrected}** documentos corrigidos\n‚ùå **{failed}** documentos n√£o encontrados\nüîÑ **{len(user_data)}** usu√°rios carregados",
            inline=False
        )
        
        success_embed.add_field(
            name="üéØ Pr√≥ximos Passos",
            value="Os rankings agora devem mostrar os usu√°rios corretamente!",
            inline=False
        )
        
        await msg.edit(embed=success_embed)
        
    except Exception as e:
        error_embed = discord.Embed(
            title="‚ùå Erro na Corre√ß√£o",
            description=f"Erro: {str(e)}",
            color=0xFF0000
        )
        await msg.edit(embed=error_embed)

@bot.command(name='status_dados')
async def status_dados(ctx):
    # S√≥ o dono do bot pode usar
    if str(ctx.author.id) != "983196900910039090":
        await ctx.reply("‚ùå Apenas o dono do bot pode usar este comando!")
        return
    
    embed = discord.Embed(
        title="üìä Status dos Dados do Bot",
        description="Informa√ß√µes sobre persist√™ncia de dados no MongoDB",
        color=0x00FF00
    )
    
    embed.add_field(
        name="üë• Usu√°rios Registrados",
        value=f"**{len(user_data)}** usu√°rios",
        inline=True
    )
    
    embed.add_field(
        name="üí∞ Dados de Economia",
        value=f"**{len(economy_data)}** usu√°rios",
        inline=True
    )
    
    embed.add_field(
        name="ü§ù Relacionamentos",
        value=f"**{len(follow_data)}** usu√°rios",
        inline=True
    )
    
    embed.add_field(
        name="üì¶ Invent√°rios",
        value=f"**{len(inventory_data)}** usu√°rios",
        inline=True
    )
    
    embed.add_field(
        name="üìù Posts com Marcas",
        value=f"**{len(brand_posts_data)}** usu√°rios",
        inline=True
    )
    
    embed.add_field(
        name="üîÑ Sistema de Reset",
        value=f"**{len(reset_data)}** usu√°rios usaram",
        inline=True
    )
    
    # Status da conex√£o MongoDB
    mongodb_status = "‚úÖ Conectado" if db is not None else "‚ùå Desconectado"
    
    embed.add_field(
        name="üçÉ Status MongoDB",
        value=mongodb_status,
        inline=False
    )
    
    try:
        if db is not None:
            # Verifica quantos documentos existem em cada cole√ß√£o
            collections_info = []
            collections_info.append(f"üë• user_data: {db.user_data.count_documents({})} docs")
            collections_info.append(f"üí∞ economy_data: {db.economy_data.count_documents({})} docs")
            collections_info.append(f"ü§ù follow_data: {db.follow_data.count_documents({})} docs")
            collections_info.append(f"üì¶ inventory_data: {db.inventory_data.count_documents({})} docs")
            collections_info.append(f"üìù brand_posts_data: {db.brand_posts_data.count_documents({})} docs")
            collections_info.append(f"üîÑ reset_data: {db.reset_data.count_documents({})} docs")
            
            embed.add_field(
                name="üìö Cole√ß√µes MongoDB",
                value="\n".join(collections_info),
                inline=False
            )
    except Exception as e:
        embed.add_field(
            name="‚ö†Ô∏è Erro ao verificar MongoDB",
            value=f"Erro: {str(e)[:100]}...",
            inline=False
        )
    
    embed.set_footer(text="Sistema MongoDB v3.0")
    await ctx.reply(embed=embed)

# Comando para verificar atividade recente
@bot.command(name='atividade')
async def atividade(ctx):
    user_id = str(ctx.author.id)

    if user_id not in user_data:
        embed = discord.Embed(
            title="‚ùå Registro necess√°rio",
            description="Voc√™ precisa se registrar primeiro!",
            color=0xFF0000
        )
        await ctx.reply(embed=embed)
        return

    # Pega dados do usu√°rio
    user_info = user_data[user_id]
    likes = user_info.get('total_likes', 0)
    followers = user_info.get('followers', 0)
    following_count = len(follow_data.get(user_id, {}).get("following", []))
    followers_count = len(follow_data.get(user_id, {}).get("followers", []))

    # Calcula pontua√ß√£o de atividade
    activity_score = (likes * 2) + (following_count * 5) + (followers_count * 3)

    # Classifica atividade
    if activity_score >= 1000:
        status = "üî• SUPER ATIVO"
        cor = 0xFF0000
    elif activity_score >= 500:
        status = "‚ö° MUITO ATIVO"
        cor = 0xFF6B35
    elif activity_score >= 200:
        status = "üìà ATIVO"
        cor = 0xFFD23F
    elif activity_score >= 50:
        status = "üìä MODERADO"
        cor = 0x06FFA5
    else:
        status = "üò¥ POUCO ATIVO"
        cor = 0x95E1D3

    embed = discord.Embed(
        title="üì± Relat√≥rio de Atividade",
        description=f"An√°lise da atividade de **{ctx.author.display_name}**",
        color=cor
    )

    embed.add_field(
        name="üèÜ Pontua√ß√£o de Atividade",
        value=f"**{activity_score:,}** pontos".replace(",", "."),
        inline=True
    )

    embed.add_field(
        name="üìä Status",
        value=status,
        inline=True
    )

    embed.add_field(
        name="üìà Estat√≠sticas Detalhadas",
        value=f"üíñ **{likes:,}** curtidas recebidas\nüë• **{following_count}** pessoas seguindo\nüë§ **{followers_count}** seguidores reais\nüìä **{followers:,}** seguidores totais".replace(",", "."),
        inline=False
    )

    # Dicas baseadas na atividade
    if activity_score < 100:
        embed.add_field(
            name="üí° Dicas para Aumentar Atividade",
            value="‚Ä¢ Envie mais mensagens nos canais\n‚Ä¢ Siga mais pessoas com `m!seguir`\n‚Ä¢ Interaja mais com a comunidade",
            inline=False
        )

    embed.set_thumbnail(url=ctx.author.display_avatar.url)
    embed.set_footer(text=f"Dev: YevgennyMXP ‚Ä¢ Relat√≥rio gerado para {ctx.author.display_name}")

    await ctx.reply(embed=embed)

# Comando para mostrar amigos m√∫tuos de um usu√°rio
@bot.command(name='amigos')
async def amigos(ctx, member: discord.Member = None):
    if member is None:
        member = ctx.author

    user_id = str(member.id)

    # Verifica se o usu√°rio est√° registrado
    if user_id not in user_data:
        if member == ctx.author:
            embed = discord.Embed(
                title="‚ùå Registro necess√°rio",
                description="Voc√™ precisa se registrar primeiro!",
                color=0xFF0000
            )
            embed.add_field(
                name="üìù Como se registrar:",
                value="Use o comando `m!seguidores` para criar seu perfil",
                inline=False
            )
            await ctx.reply(embed=embed)
        else:
            await ctx.reply(f"‚ùå {member.display_name} ainda n√£o se registrou!")
        return

    # Pega dados de relacionamentos
    user_following = follow_data.get(user_id, {}).get("following", [])
    user_followers = follow_data.get(user_id, {}).get("followers", [])

    # Encontra amigos m√∫tuos (pessoas que seguem e s√£o seguidas de volta)
    mutual_friends = []
    for friend_id in user_following:
        if friend_id in user_followers:  # Se est√° nas duas listas = amigo m√∫tuo
            try:
                friend_user = bot.get_user(int(friend_id))
                if friend_user and friend_id in user_data:
                    friend_followers = user_data[friend_id].get('followers', 0)
                    mutual_friends.append((friend_id, friend_user, friend_followers))
            except:
                continue

    embed = discord.Embed(
        title=f"ü§ù Amigos de {member.display_name}",
        description="Pessoas que voc√™s se seguem mutuamente",
        color=0xFF69B4
    )
    embed.set_thumbnail(url=member.display_avatar.url)

    if not mutual_friends:
        embed.add_field(
            name="üò¢ Nenhum Amigo M√∫tuo",
            value=f"**{member.display_name}** ainda n√£o tem amigos m√∫tuos.\n\nüí° Para fazer amigos, use `m!seguir @usuario` e pe√ßa para te seguirem de volta!",
            inline=False
        )
    else:
        # Ordena amigos por quantidade de seguidores (mais influentes primeiro)
        mutual_friends.sort(key=lambda x: x[2], reverse=True)

        friends_text = ""
        for i, (friend_id, friend_user, friend_followers) in enumerate(mutual_friends[:10]):  # Mostra at√© 10
            try:
                # Pega o username do Instagram
                username = user_data[friend_id].get('username', friend_user.display_name)

                # Adiciona verifica√ß√£o baseada nos n√≠veis de seguidores
                verification = ""
                if friend_id == "983196900910039090":  # Owner ID
                    verification = " <:extremomxp:1387842927602172125>"
                elif friend_followers >= 1000000:
                    verification = " <:abudabimxp:1387843390506405922>"
                elif friend_followers >= 500000:
                    verification = " <:verificadomxp:1387605173886783620>"
                else:
                    verification = " <:verificiadinmxp:1387842858912055428>"

                # Adiciona emoji baseado na quantidade de seguidores
                if friend_followers >= 25000000:
                    emoji = "üëë"
                    status = " (Dono do Bot)"
                elif friend_followers >= 5000000:
                    emoji = "üíé"
                    status = " (Mega Influencer)"
                elif friend_followers >= 1000000:
                    emoji = "üî•"
                    status = " (Influencer)"
                elif friend_followers >= 500000:
                    emoji = "‚≠ê"
                    status = " (Verificado)"
                elif friend_followers >= 100000:
                    emoji = "üìà"
                    status = " (Em Alta)"
                elif friend_followers >= 50000:
                    emoji = "üåü"
                    status = " (Popular)"
                else:
                    emoji = "üíï"
                    status = " (Amigo)"

                # Formata os seguidores
                if friend_followers > 0:
                    followers_formatted = f"{friend_followers:,}".replace(",", ".")
                    followers_info = f" ‚Ä¢ {followers_formatted} seguidores"
                else:
                    followers_info = " ‚Ä¢ Sem seguidores"

                friends_text += f"`{i+1:2d}.` {emoji} **@{username}**{verification}{status}\n      {followers_info}\n"

            except Exception as e:
                print(f"Erro ao processar amigo {friend_id}: {e}")
                continue

        if friends_text:
            embed.add_field(
                name=f"üíï Lista de Amigos ({len(mutual_friends)} total)",
                value=friends_text,
                inline=False
            )

        if len(mutual_friends) > 10:
            remaining = len(mutual_friends) - 10
            embed.add_field(
                name="üìã Lista Completa",
                value=f"‚ûï **{remaining}** amigos a mais n√£o mostrados.",
                inline=False
            )

        # Estat√≠sticas de amizade
        total_following = len(user_following)
        total_followers = len(user_followers)
        friendship_rate = (len(mutual_friends) / max(total_following, 1)) * 100

        embed.add_field(
            name="üìä Estat√≠sticas de Amizade",
            value=f"‚Ä¢ **{len(mutual_friends)}** amigos m√∫tuos\n‚Ä¢ **{total_following}** pessoas seguindo\n‚Ä¢ **{total_followers}** seguidores reais\n‚Ä¢ **{friendship_rate:.1f}%** taxa de reciprocidade",
            inline=False
        )

    

    embed.set_footer(
        text=f"Consultado por {ctx.author.display_name} ‚Ä¢ Sistema de Amizades v2.0",
        icon_url=ctx.author.display_avatar.url
    )

    await ctx.reply(embed=embed)

# Comando para top amizades (relacionamentos m√∫tuos)
@bot.command(name='amizades')
async def amizades(ctx):
    mutual_friends = []

    # Procura por relacionamentos m√∫tuos
    for user_id, data in follow_data.items():
        following = data.get("following", [])
        followers = data.get("followers", [])

        for friend_id in following:
            if friend_id in followers:  # Se est√£o nas duas listas, s√£o amigos m√∫tuos
                # Evita duplicatas ordenando os IDs
                pair = tuple(sorted([user_id, friend_id]))
                if pair not in [tuple(sorted([u1, u2])) for u1, u2, _ in mutual_friends]:
                    try:
                        user1 = bot.get_user(int(user_id))
                        user2 = bot.get_user(int(friend_id))
                        if user1 and user2 and user_id in user_data and friend_id in user_data:
                            # Calcula "for√ßa da amizade" baseada na soma dos seguidores
                            strength = user_data[user_id].get('followers', 0) + user_data[friend_id].get('followers', 0)
                            mutual_friends.append((user_id, friend_id, strength))
                    except:
                        continue

    if not mutual_friends:
        embed = discord.Embed(
            title="üò¢ Nenhuma Amizade Encontrada",
            description="Ainda n√£o h√° amizades m√∫tuas no servidor!",
            color=0x9932CC
        )
        embed.add_field(
            name="üí° Como Fazer Amizades",
            value="Use `m!seguir @usuario` e pe√ßa para te seguirem de volta!",
            inline=False
        )
        await ctx.reply(embed=embed)
        return

    # Ordena por for√ßa da amizade
    mutual_friends.sort(key=lambda x: x[2], reverse=True)

    embed = discord.Embed(
        title="ü§ù Top Amizades do Servidor",
        description="Relacionamentos m√∫tuos mais fortes:",
        color=0xFF69B4
    )

    for i, (user_id1, user_id2, strength) in enumerate(mutual_friends[:10]):
        try:
            user1 = bot.get_user(int(user_id1))
            user2 = bot.get_user(int(user_id2))

            username1 = user_data[user_id1].get('username', user1.display_name)
            username2 = user_data[user_id2].get('username', user2.display_name)

            # Adiciona verifica√ß√£o baseada nos n√≠veis de seguidores
            followers1 = user_data[user_id1].get('followers', 0)
            followers2 = user_data[user_id2].get('followers', 0)
            
            if user_id1 == "983196900910039090":
                username1 += " <:extremomxp:1387842927602172125>"
            elif followers1 >= 1000000:
                username1 += " <:abudabimxp:1387843390506405922>"
            elif followers1 >= 500000:
                username1 += " <:verificadomxp:1387605173886783620>"
            else:
                username1 += " <:verificiadinmxp:1387842858912055428>"
                
            if user_id2 == "983196900910039090":
                username2 += " <:extremomxp:1387842927602172125>"
            elif followers2 >= 1000000:
                username2 += " <:abudabimxp:1387843390506405922>"
            elif followers2 >= 500000:
                username2 += " <:verificadomxp:1387605173886783620>"
            else:
                username2 += " <:verificiadinmxp:1387842858912055428>"

            # Emoji baseado na posi√ß√£o
            if i == 0:
                emoji = "üëë"
            elif i == 1:
                emoji = "üíé"
            elif i == 2:
                emoji = "üî•"
            else:
                emoji = "üíï"

            embed.add_field(
                name=f"{emoji} Amizade #{i+1}",
                value=f"**@{username1}** ‚ÜîÔ∏è **@{username2}**\nüí™ For√ßa: {strength:,}".replace(",", "."),
                inline=False
            )
        except:
            continue

    embed.set_footer(text=f"Dev: YevgennyMXP ‚Ä¢ Consultado por {ctx.author.display_name}")
    await ctx.reply(embed=embed)

# Comando da lojinha
@bot.command(name='lojinha', aliases=['loja', 'shop'])
async def lojinha(ctx):
    user_id = str(ctx.author.id)

    # Verifica se o usu√°rio est√° registrado
    if user_id not in user_data:
        embed = discord.Embed(
            title="‚ùå Registro necess√°rio",
            description="Voc√™ precisa se registrar primeiro!",
            color=0xFF0000
        )
        embed.add_field(
            name="üìù Como se registrar:",
            value="Use o comando `m!seguidores` para criar seu perfil",
            inline=False
        )
        await ctx.reply(embed=embed)
        return

    # Inicializa dados de economia se n√£o existir
    if user_id not in economy_data:
        economy_data[user_id] = {"money": 0, "fame": 0}

    # Inicializa invent√°rio se n√£o existir
    if user_id not in inventory_data:
        inventory_data[user_id] = {"carros": [], "mansoes": [], "itens_diarios": []}

    # Embed principal da loja
    embed = discord.Embed(
        title="üõí Instagram MXP - Lojinha",
        description="Bem-vindo √† lojinha! Use seu dinheiro ganho com publicidade para comprar itens incr√≠veis!",
        color=0xE4405F
    )

    user_money = economy_data[user_id].get("money", 0)
    embed.add_field(
        name="üí∞ Seu Dinheiro",
        value=f"R$ {user_money:,}".replace(",", "."),
        inline=True
    )

    # Mostra quantos itens possui
    user_inventory = inventory_data[user_id]
    total_items = len(user_inventory["carros"]) + len(user_inventory["mansoes"]) + len(user_inventory["itens_diarios"])
    
    embed.add_field(
        name="üì¶ Seus Itens",
        value=f"{total_items} itens no invent√°rio",
        inline=True
    )

    embed.add_field(
        name="üõçÔ∏è Categorias Dispon√≠veis",
        value="üöó **Carros** - Do Gol ao Bugatti\nüè∞ **Mans√µes** - De casas simples a pal√°cios\nüõçÔ∏è **Itens do Dia a Dia** - Comida, eletr√¥nicos e mais!",
        inline=False
    )

    if user_money < 15:  # Pre√ßo do item mais barato
        embed.add_field(
            name="üí° Como Ganhar Dinheiro",
            value="‚Ä¢ Mencione marcas famosas em posts longos (40+ caracteres)\n‚Ä¢ Use `m!publi` para ver seu hist√≥rico\n‚Ä¢ Quanto mais marcas, mais dinheiro!",
            inline=False
        )

    embed.set_thumbnail(url="https://upload.wikimedia.org/wikipedia/commons/thumb/a/a5/Instagram_icon.png/1024px-Instagram_icon.png")
    embed.set_footer(text=f"Loja aberta por {ctx.author.display_name} ‚Ä¢ Use os bot√µes para navegar")

    # View com bot√µes principais
    view = LojaMainView(user_id)
    await ctx.reply(embed=embed, view=view)

# Comando para verificar compatibilidade entre usu√°rios
@bot.command(name='compatibilidade')
async def compatibilidade(ctx, member: discord.Member = None):
    if member is None:
        embed = discord.Embed(
            title="‚ùå Erro",
            description="Voc√™ precisa mencionar um usu√°rio para verificar compatibilidade!",
            color=0xFF0000
        )
        embed.add_field(
            name="üìù Uso correto:",
            value="`m!compatibilidade @usuario`",
            inline=False
        )
        await ctx.reply(embed=embed)
        return

    if member.id == ctx.author.id:
        embed = discord.Embed(
            title="üòÖ Autocompatibilidade",
            description="Voc√™ √© 100% compat√≠vel consigo mesmo! ü§î",
            color=0x9932CC
        )
        await ctx.reply(embed=embed)
        return

    user1_id = str(ctx.author.id)
    user2_id = str(member.id)

    if user1_id not in user_data or user2_id not in user_data:
        embed = discord.Embed(
            title="‚ùå Usu√°rios n√£o registrados",
            description="Ambos os usu√°rios precisam estar registrados!",
            color=0xFF0000
        )
        await ctx.reply(embed=embed)
        return

    # Dados dos usu√°rios
    user1_data = user_data[user1_id]
    user2_data = user_data[user2_id]

    # Calcula compatibilidade baseada em v√°rios fatores
    factors = []

    # Fator 1: Diferen√ßa de seguidores (quanto mais pr√≥ximo, maior compatibilidade)
    followers1 = user1_data.get('followers', 0)
    followers2 = user2_data.get('followers', 0)
    if max(followers1, followers2) > 0:
        followers_compatibility = min(followers1, followers2) / max(followers1, followers2) * 100
    else:
        followers_compatibility = 100
    factors.append(followers_compatibility)

    # Fator 2: Diferen√ßa de curtidas
    likes1 = user1_data.get('total_likes', 0)
    likes2 = user2_data.get('total_likes', 0)
    if max(likes1, likes2) > 0:
        likes_compatibility = min(likes1, likes2) / max(likes1, likes2) * 100
    else:
        likes_compatibility = 100
    factors.append(likes_compatibility)

    # Fator 3: Se j√° se seguem mutuamente (+30 pontos)
    mutual_following = 0
    if user1_id in follow_data and user2_id in follow_data:
        if user2_id in follow_data[user1_id].get("following", []) and user1_id in follow_data[user2_id].get("following", []):
            mutual_following = 30
    factors.append(mutual_following)

    # Fator 4: Fator aleat√≥rio para variedade
    import random
    random_factor = random.randint(0, 20)
    factors.append(random_factor)

    # Calcula compatibilidade final
    final_compatibility = min(100, sum(factors) / len(factors))

    # Define emoji e cor baseado na compatibilidade
    if final_compatibility >= 90:
        emoji = "üíï"
        status = "ALMA G√äMEA"
        cor = 0xFF1493
    elif final_compatibility >= 80:
        emoji = "üíñ"
        status = "SUPER COMPAT√çVEIS"
        cor = 0xFF69B4
    elif final_compatibility >= 70:
        emoji = "üíù"
        status = "MUITO COMPAT√çVEIS"
        cor = 0xFFB6C1
    elif final_compatibility >= 60:
        emoji = "üíò"
        status = "BOA COMPATIBILIDADE"
        cor = 0xFFC0CB
    elif final_compatibility >= 40:
        emoji = "üíó"
        status = "COMPATIBILIDADE M√âDIA"
        cor = 0xDDA0DD
    else:
        emoji = "üíî"
        status = "POUCO COMPAT√çVEIS"
        cor = 0x708090

    embed = discord.Embed(
        title=f"{emoji} Teste de Compatibilidade",
        description=f"Compatibilidade entre **{ctx.author.display_name}** e **{member.display_name}**",
        color=cor
    )

    embed.add_field(
        name="üíØ Resultado",
        value=f"**{final_compatibility:.1f}%**",
        inline=True
    )

    embed.add_field(
        name="üèÜ Status",
        value=f"**{status}**",
        inline=True
    )

    # An√°lise detalhada
    analysis = []
    if followers_compatibility > 80:
        analysis.append("‚úÖ Seguidores similares")
    if likes_compatibility > 80:
        analysis.append("‚úÖ Curtidas similares")
    if mutual_following > 0:
        analysis.append("‚úÖ J√° s√£o amigos m√∫tuos")
    if not analysis:
        analysis.append("üìä Perfis diferentes")

    embed.add_field(
        name="üìä An√°lise",
        value="\n".join(analysis),
        inline=False
    )

    # Dica baseada no resultado
    if final_compatibility >= 70:
        tip = "üéâ Voc√™s combinam muito! Que tal colaborarem em algum projeto?"
    elif final_compatibility >= 50:
        tip = "üë• Boa compatibilidade! Sigam um ao outro para se tornarem amigos."
    else:
        tip = "üå± Relacionamento pode crescer com mais intera√ß√£o!"

    embed.add_field(
        name="üí° Dica",
        value=tip,
        inline=False
    )

    embed.set_thumbnail(url="https://cdn.discordapp.com/emojis/1387605173886783620.png")
    embed.set_footer(text=f"Dev: YevgennyMXP ‚Ä¢ Teste solicitado por {ctx.author.display_name}")

    await ctx.reply(embed=embed)



# Sistema de leaderboard com menu dropdown elegante e pagina√ß√£o
class LeaderboardCategorySelect(discord.ui.Select):
    def __init__(self):
        options = [
            discord.SelectOption(
                label="üë• Seguidores Totais",
                description="Ranking dos usu√°rios com mais seguidores no Instagram",
                emoji="üë•",
                value="seguidores"
            ),
            discord.SelectOption(
                label="üíñ Mais Curtidos",
                description="Usu√°rios que receberam mais curtidas nas mensagens",
                emoji="üíñ",
                value="curtidas"
            ),
            discord.SelectOption(
                label="üí∞ Mais Ricos",
                description="Ranking dos usu√°rios com mais dinheiro acumulado",
                emoji="üí∞",
                value="dinheiro"
            ),
            discord.SelectOption(
                label="ü§ù Seguidores Reais",
                description="Usu√°rios com mais seguidores do servidor (jogadores reais)",
                emoji="ü§ù",
                value="reais"
            ),
            discord.SelectOption(
                label="‚≠ê Pontos de Fama",
                description="Ranking baseado nos pontos de fama acumulados",
                emoji="‚≠ê",
                value="fama"
            ),
            discord.SelectOption(
                label="üìä Mais Ativos",
                description="Usu√°rios com maior pontua√ß√£o de atividade geral",
                emoji="üìä",
                value="atividade"
            ),
            discord.SelectOption(
                label="üíé Level M√°ximo",
                description="Usu√°rios com os maiores levels (baseado em curtidas)",
                emoji="üíé",
                value="level"
            )
        ]
        
        super().__init__(
            placeholder="üìã Selecione uma categoria de ranking...",
            min_values=1,
            max_values=1,
            options=options
        )

    async def callback(self, interaction: discord.Interaction):
        category = self.values[0]
        await show_ranking_page(interaction, category, 1)

class LeaderboardPaginationView(discord.ui.View):
    def __init__(self, category, page, total_pages, sorted_data):
        super().__init__(timeout=300)
        self.category = category
        self.page = page
        self.total_pages = total_pages
        self.sorted_data = sorted_data
        
        # Adiciona bot√µes de navega√ß√£o
        if page > 1:
            self.prev_button.disabled = False
        else:
            self.prev_button.disabled = True
            
        if page < total_pages:
            self.next_button.disabled = False
        else:
            self.next_button.disabled = True

    @discord.ui.button(label="‚¨ÖÔ∏è", style=discord.ButtonStyle.secondary, disabled=True)
    async def prev_button(self, interaction: discord.Interaction, button: discord.ui.Button):
        await show_ranking_page(interaction, self.category, self.page - 1)

    @discord.ui.button(label="‚û°Ô∏è", style=discord.ButtonStyle.secondary, disabled=True)
    async def next_button(self, interaction: discord.Interaction, button: discord.ui.Button):
        await show_ranking_page(interaction, self.category, self.page + 1)

    @discord.ui.button(label="üîô Voltar ao Menu", style=discord.ButtonStyle.primary, row=1)
    async def back_button(self, interaction: discord.Interaction, button: discord.ui.Button):
        await show_main_leaderboard(interaction)

def get_ranking_data(category):
    """Obt√©m e organiza dados para um ranking espec√≠fico"""
    print(f"üîç DEBUG: Executando get_ranking_data para categoria '{category}'")
    print(f"üîç DEBUG: Total de usu√°rios em user_data: {len(user_data)}")
    
    if category == "seguidores":
        # Filtra usu√°rios com seguidores e que t√™m username
        valid_users = []
        for user_id, data in user_data.items():
            followers = data.get('followers', 0)
            username = data.get('username')
            print(f"üîç DEBUG: Analisando user_id {user_id}: username='{username}', followers={followers}")
            
            # Debug detalhado da valida√ß√£o
            has_followers = followers > 0
            has_username = username is not None and str(username).strip() != ""
            print(f"üîç DEBUG: has_followers={has_followers}, has_username={has_username}, username_stripped='{str(username).strip() if username else 'None'}'")
            
            # S√≥ inclui usu√°rios que tem seguidores E tem username definido (n√£o None e n√£o vazio)
            if has_followers and has_username:
                # Formato: (username, data, valor, tem_discord_user)
                valid_users.append((username, data, followers, True))
                print(f"‚úÖ DEBUG: Usu√°rio @{username} INCLU√çDO no ranking")
            else:
                print(f"‚ùå DEBUG: Usu√°rio {user_id} EXCLU√çDO - followers: {followers}, username: '{username}'")
        
        sorted_users = sorted(valid_users, key=lambda x: x[2], reverse=True)
        print(f"‚úÖ DEBUG: Ranking seguidores final: {len(sorted_users)} usu√°rios v√°lidos")
        for i, (username, data, followers, has_user) in enumerate(sorted_users[:5]):
            print(f"üèÜ DEBUG: #{i+1} - @{username} - {followers} seguidores")
        
        return sorted_users
    
    elif category == "curtidas":
        # Inclui apenas usu√°rios que t√™m username definido
        valid_users = []
        for user_id, data in user_data.items():
            likes = data.get('total_likes', 0)
            username = data.get('username')
            if username and username.strip():
                valid_users.append((username, data, likes, True))
        return sorted(valid_users, key=lambda x: x[2], reverse=True)
    
    elif category == "dinheiro":
        users_with_money = []
        for user_id, data in user_data.items():
            username = data.get('username')
            # S√≥ inclui se tem username
            if not (username and username.strip()):
                continue
            # Inicializa economia se n√£o existir
            if user_id not in economy_data:
                economy_data[user_id] = {"money": 0, "fame": 0}
            money = economy_data[user_id].get('money', 0)
            users_with_money.append((username, data, money, True))
        return sorted(users_with_money, key=lambda x: x[2], reverse=True)
    
    elif category == "reais":
        users_with_real_followers = []
        for user_id, data in user_data.items():
            username = data.get('username')
            # S√≥ inclui se tem username
            if not (username and username.strip()):
                continue
            real_followers = len(follow_data.get(user_id, {}).get("followers", []))
            users_with_real_followers.append((username, data, real_followers, True))
        return sorted(users_with_real_followers, key=lambda x: x[2], reverse=True)
    
    elif category == "fama":
        users_with_fame = []
        for user_id, data in user_data.items():
            username = data.get('username')
            # S√≥ inclui se tem username
            if not (username and username.strip()):
                continue
            # Inicializa economia se n√£o existir
            if user_id not in economy_data:
                economy_data[user_id] = {"money": 0, "fame": 0}
            fame = economy_data[user_id].get('fame', 0)
            users_with_fame.append((username, data, fame, True))
        return sorted(users_with_fame, key=lambda x: x[2], reverse=True)
    
    elif category == "atividade":
        users_with_activity = []
        for user_id, data in user_data.items():
            username = data.get('username')
            # S√≥ inclui se tem username
            if not (username and username.strip()):
                continue
            likes = data.get('total_likes', 0)
            following_count = len(follow_data.get(user_id, {}).get("following", []))
            followers_count = len(follow_data.get(user_id, {}).get("followers", []))
            activity_score = (likes * 2) + (following_count * 5) + (followers_count * 3)
            users_with_activity.append((username, data, activity_score, True))
        return sorted(users_with_activity, key=lambda x: x[2], reverse=True)
    
    elif category == "level":
        users_with_level = []
        for user_id, data in user_data.items():
            username = data.get('username')
            # S√≥ inclui se tem username
            if not (username and username.strip()):
                continue
            likes = data.get('total_likes', 0)
            if user_id == "983196900910039090":  # Owner ID
                level = 500
            else:
                level = min(likes // 10, 100)
            users_with_level.append((username, data, level, True))
        return sorted(users_with_level, key=lambda x: x[2], reverse=True)
    
    return []

def get_ranking_config(category):
    """Retorna configura√ß√£o espec√≠fica para cada tipo de ranking"""
    configs = {
        "seguidores": {
            "title": "üë• Top Seguidores Totais",
            "description": "Usu√°rios com mais seguidores no Instagram",
            "color": 0x9932CC,
            "value_key": "followers",
            "value_format": lambda x: f"üë• {x:,} seguidores".replace(",", "."),
            "emoji": "üë•"
        },
        "curtidas": {
            "title": "üíñ Top Mais Curtidos",
            "description": "Usu√°rios com mais curtidas recebidas",
            "color": 0xFF69B4,
            "value_key": "total_likes",
            "value_format": lambda x: f"üíñ {x:,} curtidas".replace(",", "."),
            "emoji": "üíñ"
        },
        "dinheiro": {
            "title": "üí∞ Top Mais Ricos",
            "description": "Usu√°rios com mais dinheiro acumulado",
            "color": 0xFFD700,
            "value_key": None,  # Valor vem do terceiro elemento da tupla
            "value_format": lambda x: f"üí∞ R$ {x:,}".replace(",", "."),
            "emoji": "üí∞"
        },
        "reais": {
            "title": "ü§ù Top Seguidores Reais",
            "description": "Usu√°rios com mais seguidores do servidor",
            "color": 0x1DA1F2,
            "value_key": None,  # Valor vem do terceiro elemento da tupla
            "value_format": lambda x: f"ü§ù {x:,} seguidores reais".replace(",", "."),
            "emoji": "ü§ù"
        },
        "fama": {
            "title": "‚≠ê Top Pontos de Fama",
            "description": "Usu√°rios com mais pontos de fama",
            "color": 0xFFE135,
            "value_key": None,  # Valor vem do terceiro elemento da tupla
            "value_format": lambda x: f"‚≠ê {x:,} pontos de fama".replace(",", "."),
            "emoji": "‚≠ê"
        },
        "atividade": {
            "title": "üìä Top Mais Ativos",
            "description": "Usu√°rios com maior atividade no servidor",
            "color": 0x00D2FF,
            "value_key": None,  # Valor vem do terceiro elemento da tupla
            "value_format": lambda x: f"üìä {x:,} pontos de atividade".replace(",", "."),
            "emoji": "üìä"
        },
        "level": {
            "title": "üíé Top Levels",
            "description": "Usu√°rios com os maiores levels",
            "color": 0x6A0DAD,
            "value_key": None,  # Valor vem do terceiro elemento da tupla
            "value_format": lambda x: f"üíé Level {x}",
            "emoji": "üíé"
        }
    }
    return configs.get(category, configs["seguidores"])

async def show_ranking_page(interaction, category, page):
    """Mostra uma p√°gina espec√≠fica do ranking"""
    print(f"üîç DEBUG: show_ranking_page chamada - categoria: {category}, p√°gina: {page}")
    
    config = get_ranking_config(category)
    sorted_data = get_ranking_data(category)
    
    print(f"üîç DEBUG: sorted_data retornado: {len(sorted_data)} itens")
    for i, item in enumerate(sorted_data[:3]):
        print(f"üîç DEBUG: Item {i}: {item}")
    
    # Converte dados para formato padr√£o - agora usando username diretamente
    valid_users = []
    for item in sorted_data:
        if len(item) == 4:  # Formato (username, data, value, has_user)
            username, data, value, has_user = item
            valid_users.append((username, data, value, None))  # None = n√£o precisa do objeto user
            print(f"‚úÖ DEBUG: Usu√°rio v√°lido adicionado: @{username} - {value}")
        else:
            print(f"‚ùå DEBUG: Formato inv√°lido: {item}")
            continue
    
    print(f"üîç DEBUG: valid_users final: {len(valid_users)} usu√°rios")
    
    if not valid_users:
        print(f"‚ùå DEBUG: Nenhum usu√°rio v√°lido encontrado!")
        embed = discord.Embed(
            title=config["title"],
            description="‚ùå Nenhum usu√°rio encontrado nesta categoria ainda.\n\nOs usu√°rios aparecer√£o aqui ap√≥s se registrarem com `m!seguidores`!",
            color=config["color"]
        )
        embed.add_field(
            name="üí° Como aparecer no ranking:",
            value="1. Use `m!seguidores` para se registrar\n2. Use `m!atualizar` para definir seu nome\n3. Interaja no servidor para ganhar curtidas/seguidores",
            inline=False
        )
        embed.add_field(
            name="üîß Debug Info:",
            value=f"‚Ä¢ Dados encontrados: {len(sorted_data)}\n‚Ä¢ Usu√°rios v√°lidos: {len(valid_users)}\n‚Ä¢ Categoria: {category}",
            inline=False
        )
        view = discord.ui.View()
        back_button = discord.ui.Button(label="üîô Voltar ao Menu", style=discord.ButtonStyle.primary)
        back_button.callback = lambda i: show_main_leaderboard(i)
        view.add_item(back_button)
        await interaction.response.edit_message(embed=embed, view=view)
        return
    
    # Pagina√ß√£o
    per_page = 10
    total_pages = (len(valid_users) + per_page - 1) // per_page
    start_idx = (page - 1) * per_page
    end_idx = start_idx + per_page
    page_users = valid_users[start_idx:end_idx]
    
    print(f"üîç DEBUG: Pagina√ß√£o - total_pages: {total_pages}, page_users: {len(page_users)}")
    
    # Cria embed
    embed = discord.Embed(
        title=config["title"],
        description=f"{config['description']} ‚Ä¢ P√°gina {page} de {total_pages}",
        color=config["color"]
    )
    
    # Ranking da p√°gina
    ranking_text = ""
    for i, (username, data, value, user_obj) in enumerate(page_users):
        global_position = start_idx + i + 1
        # Username j√° vem direto dos dados
        display_username = username
        followers = data.get('followers', 0)
        
        print(f"üîç DEBUG: Processando usu√°rio {i+1}: @{username} - valor: {value}")
        
        # Adiciona verifica√ß√£o baseada nos seguidores
        if followers >= 25000000:  # Owner level
            display_username += " <:extremomxp:1387842927602172125>"
        elif followers >= 1000000:
            display_username += " <:abudabimxp:1387843390506405922>"
        elif followers >= 500000:
            display_username += " <:verificadomxp:1387605173886783620>"
        else:
            display_username += " <:verificiadinmxp:1387842858912055428>"
        
        # Medal baseado na posi√ß√£o global
        if global_position == 1:
            medal = "üëë"
        elif global_position == 2:
            medal = "ü•à"
        elif global_position == 3:
            medal = "ü•â"
        else:
            medal = f"`{global_position:2d}`"
        
        value_text = config["value_format"](value)
        ranking_text += f"{medal} **@{display_username}**\n      {value_text}\n\n"
    
    print(f"üîç DEBUG: ranking_text final length: {len(ranking_text)}")
    print(f"üîç DEBUG: ranking_text preview: {ranking_text[:200]}...")
    
    if ranking_text.strip():
        embed.add_field(name="üèÖ Ranking", value=ranking_text.strip(), inline=False)
    else:
        embed.add_field(name="üèÖ Ranking", value="‚ö†Ô∏è Erro ao gerar ranking - debug ativo", inline=False)
        embed.add_field(name="üîß Debug", value=f"Usu√°rios: {len(page_users)}\nCategoria: {category}\nValores: {[u[2] for u in page_users]}", inline=False)
    
    # Estat√≠sticas da categoria
    if valid_users:
        leader_value = valid_users[0][2]
        total_users = len(valid_users)
        average_value = sum(item[2] for item in valid_users) / total_users
        
        stats_text = f"üëë **L√≠der:** {config['value_format'](leader_value)}\n"
        stats_text += f"üìä **M√©dia:** {config['value_format'](int(average_value))}\n"
        stats_text += f"üë• **Total ativo:** {total_users} usu√°rios"
        
        embed.add_field(name="üìà Estat√≠sticas", value=stats_text, inline=False)
    
    embed.set_thumbnail(url=f"https://cdn.discordapp.com/emojis/1376731577106567319.png")
    embed.set_footer(text=f"P√°gina {page} de {total_pages} ‚Ä¢ Solicitado por {interaction.user.display_name}")
    
    # View com bot√µes de navega√ß√£o
    view = LeaderboardPaginationView(category, page, total_pages, valid_users)
    
    print(f"üîç DEBUG: Enviando embed para Discord...")
    print(f"üîç DEBUG: Embed title: {embed.title}")
    print(f"üîç DEBUG: Embed fields: {len(embed.fields)}")
    
    try:
        await interaction.response.edit_message(embed=embed, view=view)
        print(f"‚úÖ DEBUG: Embed enviado com sucesso!")
    except Exception as e:
        print(f"‚ùå DEBUG: Erro ao enviar embed: {e}")
        # Fallback embed mais simples
        fallback_embed = discord.Embed(
            title="üîß Debug Mode - Rankings",
            description=f"Categoria: {category}\nDados encontrados: {len(valid_users)} usu√°rios",
            color=0xFF0000
        )
        
        # Mostra dados de forma mais simples
        simple_ranking = ""
        for i, (user_id, data, value, user) in enumerate(page_users[:5]):
            username = data.get('username') or user.display_name
            simple_ranking += f"{i+1}. {username}: {value}\n"
        
        if simple_ranking:
            fallback_embed.add_field(name="Top Usu√°rios", value=simple_ranking, inline=False)
        
        await interaction.response.edit_message(embed=fallback_embed, view=view)

async def show_main_leaderboard(interaction):
    """Mostra o menu principal do leaderboard"""
    embed = discord.Embed(
        title="üèÜ Leaderboard do Instagram MXP",
        description="**Menu Dropdown Elegante** üìã\n\nSelecione uma categoria no menu abaixo para ver os rankings organizados por p√°ginas.",
        color=0xFFD700
    )
    
    total_users = len(user_data)
    total_registered = len([u for u in user_data.values() if u.get('username')])
    
    embed.add_field(
        name="üìä Rankings Dispon√≠veis",
        value="üë• **Seguidores Totais** - Ranking principal por seguidores\nüíñ **Mais Curtidos** - Quem recebe mais likes\nüí∞ **Mais Ricos** - Patrim√¥nio acumulado\nü§ù **Seguidores Reais** - Conex√µes no servidor\n‚≠ê **Pontos de Fama** - Fama por publicidade\nüìä **Mais Ativos** - Atividade geral\nüíé **Level M√°ximo** - Progress√£o por curtidas",
        inline=False
    )
    
    embed.add_field(
        name="üìà Estat√≠sticas Gerais",
        value=f"üìä **{total_users}** usu√°rios no sistema\n‚úÖ **{total_registered}** usu√°rios ativos\nüèÜ Rankings atualizados em tempo real\nüìÑ **10 usu√°rios** por p√°gina",
        inline=False
    )
    
    embed.add_field(
        name="üéØ Como Usar",
        value="1Ô∏è‚É£ Selecione categoria no menu dropdown\n2Ô∏è‚É£ Navegue com ‚¨ÖÔ∏è ‚û°Ô∏è entre p√°ginas\n3Ô∏è‚É£ Use üîô para voltar ao menu principal\n4Ô∏è‚É£ Rankings atualizados automaticamente",
        inline=False
    )
    
    embed.set_thumbnail(url="https://cdn.discordapp.com/emojis/1376731577106567319.png")
    embed.set_footer(text=f"Sistema de Rankings v3.0 ‚Ä¢ Solicitado por {interaction.user.display_name}")
    
    # View com select menu
    view = discord.ui.View(timeout=300)
    view.add_item(LeaderboardCategorySelect())
    
    await interaction.response.edit_message(embed=embed, view=view)

class MainLeaderboardView(discord.ui.View):
    def __init__(self):
        super().__init__(timeout=300)
        self.add_item(LeaderboardCategorySelect())

# ===== ADMIN-ONLY COMMANDS (HIDDEN) =====
@bot.command(name='addseguidores', hidden=True)
async def add_seguidores(ctx, member: discord.Member = None, quantidade: int = None):
    """Comando secreto para adicionar seguidores (apenas owner)"""
    # Verifica se √© o owner
    if str(ctx.author.id) != "983196900910039090":
        return  # Silenciosamente ignora se n√£o for o owner
    
    if member is None or quantidade is None:
        await ctx.reply("‚ùå Uso: `m!addseguidores @usuario quantidade`", ephemeral=True)
        return
    
    user_id = str(member.id)
    
    # Verifica se o usu√°rio est√° registrado
    if user_id not in user_data:
        await ctx.reply("‚ùå Usu√°rio n√£o registrado!", ephemeral=True)
        return
    
    # Adiciona seguidores
    user_data[user_id]['followers'] += quantidade
    save_user_data()
    
    embed = discord.Embed(
        title="‚úÖ Seguidores Adicionados",
        description=f"**+{quantidade:,}** seguidores adicionados para {member.display_name}".replace(",", "."),
        color=0x00FF00
    )
    embed.add_field(
        name="üìä Total Atual",
        value=f"{user_data[user_id]['followers']:,} seguidores".replace(",", "."),
        inline=False
    )
    embed.set_footer(text="üîí Comando de Administra√ß√£o")
    await ctx.reply(embed=embed, ephemeral=True)

@bot.command(name='removeseguidores', hidden=True)
async def remove_seguidores(ctx, member: discord.Member = None, quantidade: int = None):
    """Comando secreto para remover seguidores (apenas owner)"""
    # Verifica se √© o owner
    if str(ctx.author.id) != "983196900910039090":
        return  # Silenciosamente ignora se n√£o for o owner
    
    if member is None or quantidade is None:
        await ctx.reply("‚ùå Uso: `m!removeseguidores @usuario quantidade`", ephemeral=True)
        return
    
    user_id = str(member.id)
    
    # Verifica se o usu√°rio est√° registrado
    if user_id not in user_data:
        await ctx.reply("‚ùå Usu√°rio n√£o registrado!", ephemeral=True)
        return
    
    # Remove seguidores (m√≠nimo 0)
    user_data[user_id]['followers'] = max(0, user_data[user_id]['followers'] - quantidade)
    save_user_data()
    
    embed = discord.Embed(
        title="‚úÖ Seguidores Removidos",
        description=f"**-{quantidade:,}** seguidores removidos de {member.display_name}".replace(",", "."),
        color=0xFF6B35
    )
    embed.add_field(
        name="üìä Total Atual",
        value=f"{user_data[user_id]['followers']:,} seguidores".replace(",", "."),
        inline=False
    )
    embed.set_footer(text="üîí Comando de Administra√ß√£o")
    await ctx.reply(embed=embed, ephemeral=True)

@bot.command(name='addmoney', hidden=True)
async def add_money(ctx, member: discord.Member = None, quantidade: int = None):
    """Comando secreto para adicionar dinheiro (apenas owner)"""
    # Verifica se √© o owner
    if str(ctx.author.id) != "983196900910039090":
        return  # Silenciosamente ignora se n√£o for o owner
    
    if member is None or quantidade is None:
        await ctx.reply("‚ùå Uso: `m!addmoney @usuario quantidade`", ephemeral=True)
        return
    
    user_id = str(member.id)
    
    # Verifica se o usu√°rio est√° registrado
    if user_id not in user_data:
        await ctx.reply("‚ùå Usu√°rio n√£o registrado!", ephemeral=True)
        return
    
    # Inicializa economia se n√£o existir
    if user_id not in economy_data:
        economy_data[user_id] = {"money": 0, "fame": 0}
    
    # Adiciona dinheiro
    economy_data[user_id]["money"] += quantidade
    save_economy_data()
    
    embed = discord.Embed(
        title="‚úÖ Dinheiro Adicionado",
        description=f"**+R$ {quantidade:,}** adicionados para {member.display_name}".replace(",", "."),
        color=0x00FF00
    )
    embed.add_field(
        name="üí∞ Total Atual",
        value=f"R$ {economy_data[user_id]['money']:,}".replace(",", "."),
        inline=False
    )
    embed.set_footer(text="üîí Comando de Administra√ß√£o")
    await ctx.reply(embed=embed, ephemeral=True)

@bot.command(name='removemoney', hidden=True)
async def remove_money(ctx, member: discord.Member = None, quantidade: int = None):
    """Comando secreto para remover dinheiro (apenas owner)"""
    # Verifica se √© o owner
    if str(ctx.author.id) != "983196900910039090":
        return  # Silenciosamente ignora se n√£o for o owner
    
    if member is None or quantidade is None:
        await ctx.reply("‚ùå Uso: `m!removemoney @usuario quantidade`", ephemeral=True)
        return
    
    user_id = str(member.id)
    
    # Verifica se o usu√°rio est√° registrado
    if user_id not in user_data:
        await ctx.reply("‚ùå Usu√°rio n√£o registrado!", ephemeral=True)
        return
    
    # Inicializa economia se n√£o existir
    if user_id not in economy_data:
        economy_data[user_id] = {"money": 0, "fame": 0}
    
    # Remove dinheiro (m√≠nimo 0)
    economy_data[user_id]["money"] = max(0, economy_data[user_id]["money"] - quantidade)
    save_economy_data()
    
    embed = discord.Embed(
        title="‚úÖ Dinheiro Removido",
        description=f"**-R$ {quantidade:,}** removidos de {member.display_name}".replace(",", "."),
        color=0xFF6B35
    )
    embed.add_field(
        name="üí∞ Total Atual",
        value=f"R$ {economy_data[user_id]['money']:,}".replace(",", "."),
        inline=False
    )
    embed.set_footer(text="üîí Comando de Administra√ß√£o")
    await ctx.reply(embed=embed, ephemeral=True)

@bot.command(name='addcurtidas', hidden=True)
async def add_curtidas(ctx, member: discord.Member = None, quantidade: int = None):
    """Comando secreto para adicionar curtidas (apenas owner)"""
    # Verifica se √© o owner
    if str(ctx.author.id) != "983196900910039090":
        return  # Silenciosamente ignora se n√£o for o owner
    
    if member is None or quantidade is None:
        await ctx.reply("‚ùå Uso: `m!addcurtidas @usuario quantidade`", ephemeral=True)
        return
    
    user_id = str(member.id)
    
    # Verifica se o usu√°rio est√° registrado
    if user_id not in user_data:
        await ctx.reply("‚ùå Usu√°rio n√£o registrado!", ephemeral=True)
        return
    
    # Adiciona curtidas
    user_data[user_id]['total_likes'] += quantidade
    save_user_data()
    
    embed = discord.Embed(
        title="‚úÖ Curtidas Adicionadas",
        description=f"**+{quantidade:,}** curtidas adicionadas para {member.display_name}".replace(",", "."),
        color=0x00FF00
    )
    embed.add_field(
        name="üíñ Total Atual",
        value=f"{user_data[user_id]['total_likes']:,} curtidas".replace(",", "."),
        inline=False
    )
    embed.set_footer(text="üîí Comando de Administra√ß√£o")
    await ctx.reply(embed=embed, ephemeral=True)

@bot.command(name='removecurtidas', hidden=True)
async def remove_curtidas(ctx, member: discord.Member = None, quantidade: int = None):
    """Comando secreto para remover curtidas (apenas owner)"""
    # Verifica se √© o owner
    if str(ctx.author.id) != "983196900910039090":
        return  # Silenciosamente ignora se n√£o for o owner
    
    if member is None or quantidade is None:
        await ctx.reply("‚ùå Uso: `m!removecurtidas @usuario quantidade`", ephemeral=True)
        return
    
    user_id = str(member.id)
    
    # Verifica se o usu√°rio est√° registrado
    if user_id not in user_data:
        await ctx.reply("‚ùå Usu√°rio n√£o registrado!", ephemeral=True)
        return
    
    # Remove curtidas (m√≠nimo 0)
    user_data[user_id]['total_likes'] = max(0, user_data[user_id]['total_likes'] - quantidade)
    save_user_data()
    
    embed = discord.Embed(
        title="‚úÖ Curtidas Removidas",
        description=f"**-{quantidade:,}** curtidas removidas de {member.display_name}".replace(",", "."),
        color=0xFF6B35
    )
    embed.add_field(
        name="üíñ Total Atual",
        value=f"{user_data[user_id]['total_likes']:,} curtidas".replace(",", "."),
        inline=False
    )
    embed.set_footer(text="üîí Comando de Administra√ß√£o")
    await ctx.reply(embed=embed, ephemeral=True)

@bot.command(name='resetall', hidden=True)
async def reset_all_profiles(ctx):
    """Comando secreto para resetar todos os perfis (apenas owner)"""
    # Verifica se √© o owner
    if str(ctx.author.id) != "983196900910039090":
        return  # Silenciosamente ignora se n√£o for o owner
    
    # Confirma a a√ß√£o
    embed = discord.Embed(
        title="‚ö†Ô∏è CONFIRMA√á√ÉO DE RESET TOTAL",
        description="**ATEN√á√ÉO:** Voc√™ est√° prestes a **DELETAR TODOS OS DADOS** de todos os usu√°rios!",
        color=0xFF0000
    )
    embed.add_field(
        name="üóëÔ∏è Dados que ser√£o removidos:",
        value="‚Ä¢ **TODOS** os perfis de usu√°rios\n‚Ä¢ **TODOS** os relacionamentos (seguir/seguidores)\n‚Ä¢ **TODA** a economia (dinheiro e fama)\n‚Ä¢ **TODOS** os invent√°rios\n‚Ä¢ **TODOS** os posts com marcas\n‚Ä¢ **TODOS** os dados de reset",
        inline=False
    )
    embed.add_field(
        name="‚ùó ATEN√á√ÉO EXTREMA:",
        value="**Esta a√ß√£o √© IRREVERS√çVEL e afetar√° TODOS os usu√°rios!**\nTodos ter√£o que se registrar novamente do zero.\n\n**‚ö†Ô∏è USE COM EXTREMA CAUTELA!**",
        inline=False
    )
    embed.add_field(
        name="üìä Dados Atuais:",
        value=f"üë• **{len(user_data)}** usu√°rios registrados\nüí∞ **{len(economy_data)}** perfis de economia\nü§ù **{len(follow_data)}** relacionamentos\nüì¶ **{len(inventory_data)}** invent√°rios\nüìù **{len(brand_posts_data)}** posts\nüîÑ **{len(reset_data)}** resets usados",
        inline=False
    )

    # Bot√µes de confirma√ß√£o
    view = discord.ui.View(timeout=60)

    # Bot√£o de confirmar
    confirm_button = discord.ui.Button(
        label="üóëÔ∏è SIM, DELETAR TUDO",
        style=discord.ButtonStyle.danger,
        emoji="‚ö†Ô∏è"
    )

    async def confirm_callback(interaction):
        if interaction.user.id != ctx.author.id:
            await interaction.response.send_message("‚ùå Apenas o owner pode confirmar!", ephemeral=True)
            return

        # Salva estat√≠sticas antes do reset
        stats_before = {
            "users": len(user_data),
            "economy": len(economy_data),
            "follow": len(follow_data),
            "inventory": len(inventory_data),
            "brand_posts": len(brand_posts_data),
            "resets": len(reset_data)
        }

        # RESETA TODOS OS DADOS
        user_data.clear()
        economy_data.clear()
        follow_data.clear()
        inventory_data.clear()
        brand_posts_data.clear()
        reset_data.clear()

        # Salva tudo vazio no MongoDB
        try:
            save_user_data()
            save_economy_data()
            save_follow_data()
            save_inventory_data()
            save_brand_posts_data()
            save_reset_data()
        except Exception as e:
            print(f"‚ùå Erro ao salvar dados zerados: {e}")

        success_embed = discord.Embed(
            title="üí• RESET TOTAL EXECUTADO!",
            description="**TODOS os dados foram completamente removidos!**",
            color=0xFF0000
        )
        
        success_embed.add_field(
            name="üìä Dados Removidos",
            value=f"üë• **{stats_before['users']}** usu√°rios deletados\nüí∞ **{stats_before['economy']}** economias deletadas\nü§ù **{stats_before['follow']}** relacionamentos deletados\nüì¶ **{stats_before['inventory']}** invent√°rios deletados\nüìù **{stats_before['brand_posts']}** posts deletados\nüîÑ **{stats_before['resets']}** resets deletados",
            inline=False
        )
        
        success_embed.add_field(
            name="üîÑ Sistema Resetado",
            value="‚Ä¢ MongoDB completamente limpo\n‚Ä¢ Todos os usu√°rios precisar√£o usar `m!seguidores` novamente\n‚Ä¢ Todos os relacionamentos foram perdidos\n‚Ä¢ Toda economia foi zerada",
            inline=False
        )
        
        success_embed.add_field(
            name="‚ö†Ô∏è Importante",
            value="**O bot est√° funcionando normalmente**, mas todos os dados foram perdidos permanentemente.",
            inline=False
        )
        
        success_embed.set_footer(text="Reset total realizado pelo owner ‚Ä¢ A√ß√£o irrevers√≠vel")

        await interaction.response.edit_message(embed=success_embed, view=None)
        
        print(f"üí• RESET TOTAL executado pelo owner! {stats_before['users']} usu√°rios deletados")

    # Bot√£o de cancelar
    cancel_button = discord.ui.Button(
        label="‚ùå CANCELAR",
        style=discord.ButtonStyle.secondary,
        emoji="üö´"
    )

    async def cancel_callback(interaction):
        if interaction.user.id != ctx.author.id:
            await interaction.response.send_message("‚ùå Apenas o owner pode cancelar!", ephemeral=True)
            return

        cancel_embed = discord.Embed(
            title="‚úÖ Reset Cancelado",
            description="**Todos os dados est√£o seguros!** Nenhuma altera√ß√£o foi feita.",
            color=0x00FF00
        )
        cancel_embed.add_field(
            name="üìä Dados Preservados",
            value=f"üë• **{len(user_data)}** usu√°rios mantidos\nüí∞ **{len(economy_data)}** economias preservadas\nü§ù **{len(follow_data)}** relacionamentos intactos",
            inline=False
        )
        cancel_embed.set_footer(text="Reset cancelado com seguran√ßa")
        await interaction.response.edit_message(embed=cancel_embed, view=None)

    confirm_button.callback = confirm_callback
    cancel_button.callback = cancel_callback

    view.add_item(confirm_button)
    view.add_item(cancel_button)

    await ctx.reply(embed=embed, view=view, ephemeral=True)

# ===== FIM DOS COMANDOS ADMIN =====

# Comando principal de leaderboard
@bot.command(name='leaderboard', aliases=['lb', 'top'])
async def leaderboard(ctx):
    embed = discord.Embed(
        title="üèÜ Leaderboard do Instagram MXP",
        description="**Menu Dropdown Elegante** üìã\n\nSelecione uma categoria no menu abaixo para ver os rankings organizados por p√°ginas.",
        color=0xFFD700
    )
    
    total_users = len(user_data)
    total_registered = len([u for u in user_data.values() if u.get('username')])
    
    embed.add_field(
        name="üìä Rankings Dispon√≠veis",
        value="üë• **Seguidores Totais** - Ranking principal por seguidores\nüíñ **Mais Curtidos** - Quem recebe mais likes\nüí∞ **Mais Ricos** - Patrim√¥nio acumulado\nü§ù **Seguidores Reais** - Conex√µes no servidor\n‚≠ê **Pontos de Fama** - Fama por publicidade\nüìä **Mais Ativos** - Atividade geral\nüíé **Level M√°ximo** - Progress√£o por curtidas",
        inline=False
    )
    
    embed.add_field(
        name="üìà Estat√≠sticas Gerais",
        value=f"üìä **{total_users}** usu√°rios no sistema\n‚úÖ **{total_registered}** usu√°rios ativos\nüèÜ Rankings atualizados em tempo real\nüìÑ **10 usu√°rios** por p√°gina",
        inline=False
    )
    
    embed.add_field(
        name="üéØ Como Usar",
        value="1Ô∏è‚É£ Selecione categoria no menu dropdown\n2Ô∏è‚É£ Navegue com ‚¨ÖÔ∏è ‚û°Ô∏è entre p√°ginas\n3Ô∏è‚É£ Use üîô para voltar ao menu principal\n4Ô∏è‚É£ Rankings atualizados automaticamente",
        inline=False
    )
    
    embed.set_thumbnail(url="https://cdn.discordapp.com/emojis/1376731577106567319.png")
    embed.set_footer(text=f"Sistema de Rankings v3.0 ‚Ä¢ Solicitado por {ctx.author.display_name}")
    
    view = MainLeaderboardView()
    await ctx.reply(embed=embed, view=view)



# Comando para verificar economia (dinheiro e fama)
@bot.command(name='economia', aliases=['saldo', 'money'])
async def economia(ctx, member: discord.Member = None):
    if member is None:
        member = ctx.author

    user_id = str(member.id)

    # Verifica se o usu√°rio est√° registrado
    if user_id not in user_data:
        if member == ctx.author:
            embed = discord.Embed(
                title="‚ùå Registro necess√°rio",
                description="Voc√™ precisa se registrar primeiro!",
                color=0xFF0000
            )
            embed.add_field(
                name="üìù Como se registrar:",
                value="Use o comando `m!seguidores` para criar seu perfil",
                inline=False
            )
            await ctx.reply(embed=embed)
        else:
            await ctx.reply(f"‚ùå {member.display_name} ainda n√£o se registrou!")
        return

    # Inicializa dados de economia se n√£o existir
    if user_id not in economy_data:
        economy_data[user_id] = {
            "money": 0,
            "fame": 0
        }

    # Pega dados do usu√°rio
    money = economy_data[user_id].get("money", 0)
    fame = economy_data[user_id].get("fame", 0)
    followers = user_data[user_id].get('followers', 0)

    # Define status baseado no dinheiro
    if money >= 100000:
        status = "üíé MAGNATA"
        cor = 0xFFD700
    elif money >= 50000:
        status = "ü§ë RICO"
        cor = 0xFF6B35
    elif money >= 20000:
        status = "üí∞ BEM SUCEDIDO"
        cor = 0x00FF00
    elif money >= 5000:
        status = "üìà CRESCENDO"
        cor = 0xFFD23F
    else:
        status = "üå± INICIANTE"
        cor = 0x9932CC

    embed = discord.Embed(
        title="üíº Economia do Instagram",
        description=f"Finan√ßas de **{member.display_name}**",
        color=cor
    )

    embed.add_field(
        name="üíµ Dinheiro",
        value=f"**R$ {money:,}**".replace(",", "."),
        inline=True
    )

    embed.add_field(
        name="‚≠ê Pontos de Fama",
        value=f"**{fame:,}** pontos".replace(",", "."),
        inline=True
    )

    embed.add_field(
        name="üèÜ Status Financeiro",
        value=status,
        inline=True
    )

    embed.add_field(
        name="üìä Seguidores Totais",
        value=f"**{followers:,}** seguidores".replace(",", "."),
        inline=True
    )

    # Calcula poder de compra
    if money >= 50000:
        poder_compra = "üî• Pode comprar qualquer coisa!"
    elif money >= 20000:
        poder_compra = "üí™ √ìtimo poder de compra"
    elif money >= 5000:
        poder_compra = "üìà Poder de compra moderado"
    else:
        poder_compra = "üå± Construindo patrim√¥nio"

    embed.add_field(
        name="üí≥ Poder de Compra",
        value=poder_compra,
        inline=True
    )

    # Dicas para ganhar dinheiro
    if money < 10000:
        embed.add_field(
            name="üí° Como Ganhar Dinheiro",
            value="‚Ä¢ Use `m!publi` ap√≥s mencionar marcas famosas\n‚Ä¢ Fa√ßa parcerias com influencers\n‚Ä¢ Crie conte√∫do patrocinado",
            inline=False
        )

    embed.set_thumbnail(url=member.display_avatar.url)
    embed.set_footer(text=f"Dev: YevgennyMXP ‚Ä¢ Consultado por {ctx.author.display_name}")

    await ctx.reply(embed=embed)

# Sistema de invent√°rio com menus
class InventoryView(discord.ui.View):
    def __init__(self, user_id):
        super().__init__(timeout=300)
        self.user_id = user_id

    @discord.ui.button(label='üöó Ver Carros', style=discord.ButtonStyle.primary)
    async def ver_carros(self, interaction: discord.Interaction, button: discord.ui.Button):
        if str(interaction.user.id) != self.user_id:
            await interaction.response.send_message("‚ùå Este invent√°rio n√£o √© seu!", ephemeral=True)
            return
        
        user_inventory = inventory_data.get(self.user_id, {"carros": [], "mansoes": [], "itens_diarios": []})
        carros = user_inventory["carros"]
        
        embed = discord.Embed(
            title="üöó Meus Carros",
            description=f"Voc√™ possui {len(carros)} carros",
            color=0x3498DB
        )
        
        if not carros:
            embed.add_field(
                name="üò¢ Nenhum Carro",
                value="Voc√™ ainda n√£o possui carros! Use `m!lojinha` para comprar.",
                inline=False
            )
        else:
            carros_text = ""
            for i, carro in enumerate(carros[:10]):  # Mostra at√© 10
                carros_text += f"`{i+1:2d}.` **{carro['nome']}**\n      üí∞ R$ {carro['preco']:,}\n".replace(",", ".")
            embed.add_field(
                name=f"üöó Lista de Carros ({len(carros)})",
                value=carros_text,
                inline=False
            )
        
        await interaction.response.edit_message(embed=embed, view=self)

    @discord.ui.button(label='üè∞ Ver Mans√µes', style=discord.ButtonStyle.secondary)
    async def ver_mansoes(self, interaction: discord.Interaction, button: discord.ui.Button):
        if str(interaction.user.id) != self.user_id:
            await interaction.response.send_message("‚ùå Este invent√°rio n√£o √© seu!", ephemeral=True)
            return
        
        user_inventory = inventory_data.get(self.user_id, {"carros": [], "mansoes": [], "itens_diarios": []})
        mansoes = user_inventory["mansoes"]
        
        embed = discord.Embed(
            title="üè∞ Minhas Mans√µes",
            description=f"Voc√™ possui {len(mansoes)} propriedades",
            color=0xE67E22
        )
        
        if not mansoes:
            embed.add_field(
                name="üò¢ Nenhuma Mans√£o",
                value="Voc√™ ainda n√£o possui mans√µes! Use `m!lojinha` para comprar.",
                inline=False
            )
        else:
            mansoes_text = ""
            for i, mansao in enumerate(mansoes[:10]):  # Mostra at√© 10
                mansoes_text += f"`{i+1:2d}.` **{mansao['nome']}**\n      üí∞ R$ {mansao['preco']:,}\n".replace(",", ".")
            embed.add_field(
                name=f"üè∞ Lista de Mans√µes ({len(mansoes)})",
                value=mansoes_text,
                inline=False
            )
        
        await interaction.response.edit_message(embed=embed, view=self)

    @discord.ui.button(label='üõçÔ∏è Ver Itens', style=discord.ButtonStyle.success)
    async def ver_itens(self, interaction: discord.Interaction, button: discord.ui.Button):
        if str(interaction.user.id) != self.user_id:
            await interaction.response.send_message("‚ùå Este invent√°rio n√£o √© seu!", ephemeral=True)
            return
        
        user_inventory = inventory_data.get(self.user_id, {"carros": [], "mansoes": [], "itens_diarios": []})
        itens = user_inventory["itens_diarios"]
        
        embed = discord.Embed(
            title="üõçÔ∏è Meus Itens",
            description=f"Voc√™ possui {len(itens)} itens",
            color=0x27AE60
        )
        
        if not itens:
            embed.add_field(
                name="üò¢ Nenhum Item",
                value="Voc√™ ainda n√£o possui itens! Use `m!lojinha` para comprar.",
                inline=False
            )
        else:
            itens_text = ""
            for i, item in enumerate(itens[:15]):  # Mostra at√© 15
                itens_text += f"`{i+1:2d}.` **{item['nome']}** - R$ {item['preco']:,}\n".replace(",", ".")
            embed.add_field(
                name=f"üõçÔ∏è Lista de Itens ({len(itens)})",
                value=itens_text,
                inline=False
            )
        
        await interaction.response.edit_message(embed=embed, view=self)

class UseItemView(discord.ui.View):
    def __init__(self, user_id):
        super().__init__(timeout=300)
        self.user_id = user_id
        
        # Adiciona select menu com os itens dispon√≠veis para usar
        user_inventory = inventory_data.get(user_id, {"carros": [], "mansoes": [], "itens_diarios": []})
        all_items = []
        
        # Adiciona carros
        for carro in user_inventory["carros"][:10]:  # Limita a 10
            all_items.append((carro["nome"], "carro", carro))
        
        # Adiciona mans√µes
        for mansao in user_inventory["mansoes"][:5]:  # Limita a 5
            all_items.append((mansao["nome"], "mansao", mansao))
        
        # Adiciona itens (apenas eletr√¥nicos, games e bebidas s√£o "us√°veis")
        for item in user_inventory["itens_diarios"][:10]:  # Limita a 10
            if any(cat in item.get("categoria", "") for cat in ["Eletr√¥nicos", "Games", "Bebidas", "Comidas"]):
                all_items.append((item["nome"], "item", item))
        
        if all_items:
            self.add_item(UseItemSelect(user_id, all_items))

class UseItemSelect(discord.ui.Select):
    def __init__(self, user_id, items):
        self.user_id = user_id
        self.items = items
        
        options = []
        for nome, tipo, item_data in items[:25]:  # Discord limita a 25
            emoji = "üöó" if tipo == "carro" else "üè∞" if tipo == "mansao" else "üõçÔ∏è"
            options.append(discord.SelectOption(
                label=f"{emoji} {nome}",
                description=f"Usar {nome}",
                value=f"{tipo}:{nome}"
            ))
        
        super().__init__(placeholder="Escolha um item para usar...", options=options)

    async def callback(self, interaction: discord.Interaction):
        if str(interaction.user.id) != self.user_id:
            await interaction.response.send_message("‚ùå Este invent√°rio n√£o √© seu!", ephemeral=True)
            return
        
        tipo, nome = self.values[0].split(":", 1)
        
        # Simula o uso do item
        embed = discord.Embed(
            title="‚úÖ Item Usado!",
            color=0x00FF00
        )
        
        if tipo == "carro":
            embed.description = f"üöó Voc√™ saiu para dirigir seu **{nome}**!"
            embed.add_field(
                name="üèÅ Experi√™ncia de Dirigir",
                value="Que passeio incr√≠vel! Voc√™ se sentiu como um verdadeiro piloto.",
                inline=False
            )
            embed.set_thumbnail(url="https://cdn.discordapp.com/emojis/1387842927602172125.png")
        
        elif tipo == "mansao":
            embed.description = f"üè∞ Voc√™ relaxou em sua **{nome}**!"
            embed.add_field(
                name="üõãÔ∏è Momento de Relaxamento",
                value="Que casa incr√≠vel! Voc√™ se sentiu como um verdadeiro rei/rainha.",
                inline=False
            )
            embed.set_thumbnail(url="https://cdn.discordapp.com/emojis/1387842927602172125.png")
        
        else:  # item
            if "Bebidas" in nome or "Coca" in nome or "Caf√©" in nome:
                embed.description = f"‚òï Voc√™ bebeu seu **{nome}**!"
                embed.add_field(
                    name="üòã Que Del√≠cia!",
                    value="Voc√™ se sentiu refreshed e energizado!",
                    inline=False
                )
            elif "Comidas" in nome or "Pizza" in nome or "Big Mac" in nome:
                embed.description = f"üçî Voc√™ comeu seu **{nome}**!"
                embed.add_field(
                    name="üòã Que Sabor!",
                    value="Voc√™ matou a fome e ficou satisfeito!",
                    inline=False
                )
            elif "Games" in nome or "PlayStation" in nome or "Xbox" in nome:
                embed.description = f"üéÆ Voc√™ jogou no seu **{nome}**!"
                embed.add_field(
                    name="üïπÔ∏è Divers√£o Garantida",
                    value="Que sess√£o de jogos incr√≠vel! Voc√™ se divertiu muito.",
                    inline=False
                )
            else:  # Eletr√¥nicos
                embed.description = f"üì± Voc√™ usou seu **{nome}**!"
                embed.add_field(
                    name="üì≤ Experi√™ncia Tech",
                    value="Que tecnologia avan√ßada! Voc√™ se sentiu conectado.",
                    inline=False
                )
        
        embed.set_footer(text=f"Item usado por {interaction.user.display_name}")
        await interaction.response.edit_message(embed=embed, view=None)

# Comando para daily reward (recompensa di√°ria)
daily_rewards = {}

@bot.command(name='inv', aliases=['inventario'])
async def inventario(ctx):
    user_id = str(ctx.author.id)
    
    if user_id not in user_data:
        embed = discord.Embed(
            title="‚ùå Registro necess√°rio",
            description="Voc√™ precisa se registrar primeiro!",
            color=0xFF0000
        )
        embed.add_field(
            name="üìù Como se registrar:",
            value="Use o comando `m!seguidores` para criar seu perfil",
            inline=False
        )
        await ctx.reply(embed=embed)
        return
    
    # Inicializa invent√°rio se n√£o existir
    if user_id not in inventory_data:
        inventory_data[user_id] = {"carros": [], "mansoes": [], "itens_diarios": []}
    
    user_inventory = inventory_data[user_id]
    total_items = len(user_inventory["carros"]) + len(user_inventory["mansoes"]) + len(user_inventory["itens_diarios"])
    
    embed = discord.Embed(
        title="üì¶ Meu Invent√°rio",
        description=f"Voc√™ possui **{total_items}** itens no total",
        color=0x9B59B6
    )
    
    embed.add_field(
        name="üöó Carros",
        value=f"**{len(user_inventory['carros'])}** carros",
        inline=True
    )
    
    embed.add_field(
        name="üè∞ Mans√µes",
        value=f"**{len(user_inventory['mansoes'])}** propriedades",
        inline=True
    )
    
    embed.add_field(
        name="üõçÔ∏è Itens",
        value=f"**{len(user_inventory['itens_diarios'])}** itens",
        inline=True
    )
    
    if total_items == 0:
        embed.add_field(
            name="üò¢ Invent√°rio Vazio",
            value="Voc√™ ainda n√£o possui itens! Use `m!lojinha` para fazer compras.",
            inline=False
        )
    else:
        embed.add_field(
            name="üîç Navega√ß√£o",
            value="Use os bot√µes abaixo para ver detalhes de cada categoria!",
            inline=False
        )
    
    embed.set_thumbnail(url="https://cdn.discordapp.com/emojis/1387842927602172125.png")
    embed.set_footer(text=f"Invent√°rio de {ctx.author.display_name}")
    
    view = InventoryView(user_id)
    await ctx.reply(embed=embed, view=view)

@bot.command(name='usar', aliases=['use'])
async def usar_item(ctx):
    user_id = str(ctx.author.id)
    
    if user_id not in user_data:
        embed = discord.Embed(
            title="‚ùå Registro necess√°rio",
            description="Voc√™ precisa se registrar primeiro!",
            color=0xFF0000
        )
        await ctx.reply(embed=embed)
        return
    
    # Inicializa invent√°rio se n√£o existir
    if user_id not in inventory_data:
        inventory_data[user_id] = {"carros": [], "mansoes": [], "itens_diarios": []}
    
    user_inventory = inventory_data[user_id]
    total_items = len(user_inventory["carros"]) + len(user_inventory["mansoes"]) + len(user_inventory["itens_diarios"])
    
    if total_items == 0:
        embed = discord.Embed(
            title="üò¢ Invent√°rio Vazio",
            description="Voc√™ n√£o possui itens para usar!",
            color=0xFF0000
        )
        embed.add_field(
            name="üõí Como Obter Itens",
            value="Use `m!lojinha` para comprar carros, mans√µes e itens!",
            inline=False
        )
        await ctx.reply(embed=embed)
        return
    
    embed = discord.Embed(
        title="üéÆ Usar Item",
        description="Escolha um item do seu invent√°rio para usar:",
        color=0x9B59B6
    )
    
    embed.add_field(
        name="üìã Itens Dispon√≠veis",
        value=f"üöó **{len(user_inventory['carros'])}** carros para dirigir\nüè∞ **{len(user_inventory['mansoes'])}** mans√µes para relaxar\nüõçÔ∏è **{len([i for i in user_inventory['itens_diarios'] if any(cat in i.get('categoria', '') for cat in ['Eletr√¥nicos', 'Games', 'Bebidas', 'Comidas'])])}** itens us√°veis",
        inline=False
    )
    
    embed.add_field(
        name="üí° Como Funciona",
        value="‚Ä¢ **Carros**: Saia para dirigir e se divertir\n‚Ä¢ **Mans√µes**: Relaxe em suas propriedades\n‚Ä¢ **Itens**: Use eletr√¥nicos, games, bebidas e comidas",
        inline=False
    )
    
    embed.set_thumbnail(url="https://cdn.discordapp.com/emojis/1381003788135174316.png")
    embed.set_footer(text=f"Solicitado por {ctx.author.display_name}")
    
    view = UseItemView(user_id)
    await ctx.reply(embed=embed, view=view)

@bot.command(name='daily')
async def daily_reward(ctx):
    user_id = str(ctx.author.id)

    if user_id not in user_data:
        embed = discord.Embed(
            title="‚ùå Registro necess√°rio",
            description="Voc√™ precisa se registrar primeiro!",
            color=0xFF0000
        )
        embed.add_field(
            name="üìù Como se registrar:",
            value="Use o comando `m!seguidores` para criar seu perfil",
            inline=False
        )
        await ctx.reply(embed=embed)
        return

    import datetime
    today = datetime.date.today().isoformat()

    # Verifica se j√° coletou hoje
    if user_id in daily_rewards and daily_rewards[user_id] == today:
        embed = discord.Embed(
            title="‚è∞ J√° coletado hoje!",
            description="Voc√™ j√° coletou sua recompensa di√°ria!",
            color=0xFF0000
        )
        embed.add_field(
            name="üïê Pr√≥xima recompensa:",
            value="Volte amanh√£ para coletar novamente!",
            inline=False
        )
        await ctx.reply(embed=embed)
        return

    # Calcula recompensa baseada nos seguidores
    followers = user_data[user_id].get('followers', 0)
    
    if followers >= 5000000:
        likes_reward = random.randint(15, 25)
        bonus = "üíé Mega Influencer"
    elif followers >= 1000000:
        likes_reward = random.randint(10, 20)
        bonus = "üî• Influencer"
    elif followers >= 500000:
        likes_reward = random.randint(8, 15)
        bonus = "‚≠ê Verificado"
    elif followers >= 100000:
        likes_reward = random.randint(5, 12)
        bonus = "üìà Popular"
    else:
        likes_reward = random.randint(3, 8)
        bonus = "üå± Crescendo"

    # Adiciona as curtidas
    user_data[user_id]['total_likes'] += likes_reward
    daily_rewards[user_id] = today
    save_user_data()

    embed = discord.Embed(
        title="üéÅ Recompensa Di√°ria Coletada!",
        description=f"Voc√™ ganhou **{likes_reward}** curtidas!",
        color=0x00FF00
    )

    embed.add_field(
        name="üíñ Curtidas Recebidas",
        value=f"+{likes_reward} curtidas",
        inline=True
    )

    embed.add_field(
        name="üèÜ B√¥nus de Status",
        value=bonus,
        inline=True
    )

    embed.add_field(
        name="üìä Total Atual",
        value=f"{user_data[user_id]['total_likes']:,} curtidas".replace(",", "."),
        inline=False
    )

    embed.add_field(
        name="‚è∞ Pr√≥xima Recompensa",
        value="Volte amanh√£ para coletar novamente!",
        inline=False
    )

    embed.set_thumbnail(url="https://cdn.discordapp.com/emojis/1381003788135174316.png")
    embed.set_footer(text=f"Recompensa coletada por {ctx.author.display_name}")

    await ctx.reply(embed=embed)



# Inicia o bot
if __name__ == "__main__":
    token = os.getenv('DISCORD_BOT_TOKEN')
    if not token:
        print("ERRO: Token do Discord n√£o encontrado!")
        print("Configure a vari√°vel DISCORD_BOT_TOKEN nas Secrets do Replit")
    else:
        bot.run(token)